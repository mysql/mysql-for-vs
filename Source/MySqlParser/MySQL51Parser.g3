// Copyright © 2013, Oracle and/or its affiliates. All rights reserved.
//
// MySQL Connector/NET is licensed under the terms of the GPLv2
// <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most 
// MySQL Connectors. There are special exceptions to the terms and 
// conditions of the GPLv2 as it is applied to this software, see the 
// FLOSS License Exception
// <http://www.mysql.com/about/legal/licensing/foss-exception.html>.
//
// This program is free software; you can redistribute it and/or modify 
// it under the terms of the GNU General Public License as published 
// by the Free Software Foundation; version 2 of the License.
//
// This program is distributed in the hope that it will be useful, but 
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
// for more details.
//
// You should have received a copy of the GNU General Public License along 
// with this program; if not, write to the Free Software Foundation, Inc., 
// 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA

parser grammar MySQL51Parser; 

options {
	language=CSharp2;
	output=AST;
	tokenVocab=MySQL51Lexer;
	/*k=*;*/
	superClass=MySQLParserBase;
}

tokens {
BEGIN_END;
CASE_STMT;
CHARACTERISTIC;
CHARACTER_SET;
CT_DATAFILE;
CT_COMMENT;
CT_LOGFILE;
CT_EXTENT_SIZE;
CT_INITIAL_SIZE;
CT_AUTOEXTEND_SIZE;
CT_MAX_SIZE;
CT_NODEGROUP;
CT_COMMENT;
CREATE_PART_OPTS;
CREATE_SERVER_OPTION;
CREATE_SERVER_OPTIONS;
CREATE_TBL_OPT;
CREATE_TBL_OPTS;
DATA_TYPE;
DATETIME_PRECISION;
DBNAME;
DECLARE_HANDLER;
ENABLING;
EXPR;
EXPR_LIST;
FOREIGNKEY_DATA_WRAPPER;
GLOBAL;
IF_COND;
ELSEIFS;
INSERT_DEFAULT_EXPR;
INTO_FROM;
LABEL;
SELECT_EXPR;
SESSION;
UNARY_MINUS;
UNARY_PLUS;
OPTIONS;
FUNC;
DIRECTION;
ALIAS;
FIELD;
SUBSELECT;
COMMA_JOIN;
COLUMNS;
INSERT_VALUES;
INDEX_HINTS;
ROLLBACK_POINT;	/* rollback to savepoint */
/* token types for the various CREATE statements */
CREATE_TABLE;
/* helper tokens for column definitions  */
NOT_NULL;
DEFINITION;
DEFINITIONS;
COUNT_STAR;
OBJ_LIST;
OBJECT_TYPE;
ON_COMPLETION;
ON_SCHEDULE;
PARAM;
PARENT_OPT_EXPR_LIST;
PRIVILEGE_LEVEL;
REPLACE_SET;
SET_PASSWORD;
SSL_OPTION;
SUBPART_DEF;
TABLE_REF;
TRIGGERTIME;
USER_HOST;
USER_HOST_OR_ID_OR_STRING;
VAR;
VAR_ASSIGN;
WITH_OPTION;
XID;
COLUMN_LIST;
}


@namespace{MySql.Parser}



public program
	: statement_list EOF
	;

public query
	: 
	(
	( ( BEGIN EOF ) | ( BEGIN WORK ) ) => ( begin_transaction )
	| statement 
	) EOF
	;

public statement_list 
	:	stmts+=statement (SEMI stmts+=statement)* SEMI*
		-> $stmts+
	;

statement options { backtrack=true; memoize=true; }
	:	(	select
		|	do_stmt
		|	show_stmt
		|	deallocate
		//|	declare_condition
		//|	declare_handler
		|	describe
		|	execute
		|	explain
		|	grant
		|	insert
		|	update
		//|	declare_stmt 
		|	delete		
		|   alter_function
		|   alter_logfile
		|   alter_procedure
		|   ( ( ALTER ONLINE ) | ( ALTER OFFLINE ) | ( ALTER IGNORE ) | ( ALTER TABLE )) => alter_table
		|	alter_tablespace		
		|   alter_server
		|	alter_view
		|	alter_user
		|   analyze_table
		|   backup_table
		|   binlog
		|   cacheindex
		|   change_master
		|   check_table
		|   checksum_table
		|	COMMENT_RULE
		|	create_database
		|	create_event
		|	create_function
		|   create_index
		|   create_logfile
		|	create_table
		|   create_tablespace
		|   create_trigger
		|	create_procedure
		|   create_server
		|   create_udf
		|	create_user
		|   create_view
		//|	cursor_declare
		|	cursor_open
		|	cursor_fetch
		|	cursor_close
		|	drop_database
		|	drop_event
		|	drop_routine
		|	drop_index
		|	drop_logfile
		|	drop_server
		|	drop_table
		|	drop_trigger
		|	drop_view
		|	drop_user
		|   flush
		|	get_diagnostics
		|   handler
		|	help
		|	if_stmt
		|   install_plugin
		|	iterate
		|   kill				
		|	leave
		|   load_data_from_master
		|   load_data_infile
		|   load_index_into_cache
		|   load_table_from_master
		|	load_xml
		|	loop
		|   optimize_table
		|	prepare
		|   purge
		|	rename_database
		|	rename_table
		|	rename_user
		|	repeat
		|   replace
		|   reset
		|   reset_master
		|   reset_slave
		|   restore_table
		|   resignal
		|	return_stmt
		|	revoke_user
		|	rollback
		|	savepoint_ident
		|	set_stmt
		|	( SET PASSWORD ) => set_password
		|   signal
		|   start_slave
		|   stop_slave
		|	begin_end_stmt
		|	transaction
		|	truncate_table		
		|	sp_call
		|	while_loop
		|   uninstall_plugin
		|	use
		|	case_stmt
		|	alter_database
		|	alter_event
		)
	;

// $< DML

begin_end_stmt options { backtrack=true; memoize=true; }
	:	(( ( beginlabel=ident_sp_label COLON ) BEGIN declare_set* statement_list? END endlabel=label_after_end?
		-> ^( BEGIN_END ^( LABEL $beginlabel $endlabel? ) declare_set* statement_list? ) ) )		
		/*| ( ( BEGIN WORK ) | ( BEGIN SEMI ) | ( BEGIN EOF ) )  => begin_transaction */
		| (
		( BEGIN declare_set* statement_list? END 
		-> ^( BEGIN_END declare_set* statement_list? ) ) )
	;

label_after_end
  : ( { ( input.LA( 1 ) != EOF ) && ( ( input.LA( 2 ) == EOF ) || ( input.LA( 2 ) == SEMI )) }? => ( ident_sp_label ) ) -> ident_sp_label
  ;
declare_set options { backtrack=true; memoize=true; }
  : 
  ( declare_stmt -> declare_stmt 
  | declare_handler -> declare_handler 
  | cursor_declare -> cursor_declare 
  | declare_condition -> declare_condition ) SEMI+
  ;

begin_transaction options { backtrack=true; memoize=true; }
	: 
		{ ( ( input.LA( 2 ) == WORK || input.LA( 2 ) == SEMI || input.LA( 2 ) == EOF ) && input.LA( 2 ) != END ) }?
			  BEGIN  WORK? 										-> ^(BEGIN WORK?)
	;

loop
	:	( ( beginlabel=ident_sp_label COLON ) LOOP statement_list? END LOOP endlabel=label_after_end?
		-> ^( LOOP ^( LABEL $beginlabel $endlabel? ) statement_list? ) )
		|
		( LOOP statement_list? END LOOP 
		-> ^( LOOP statement_list? ) )
	;

repeat
	:	( ( beginlabel=ident_sp_label COLON ) REPEAT statement_list? UNTIL where_condition END REPEAT endlabel=label_after_end?
		-> ^( REPEAT ^( LABEL $beginlabel $endlabel? ) statement_list? UNTIL where_condition ) )
		|
		( REPEAT statement_list? UNTIL where_condition END REPEAT
		-> ^( REPEAT statement_list? UNTIL where_condition  ) )
	;

while_loop
	:	( ( beginlabel=ident_sp_label COLON ) WHILE where_condition DO statement_list? END WHILE endlabel=label_after_end?
		-> ^( WHILE where_condition ^( LABEL $beginlabel $endlabel? ) statement_list?  ) )
		|
		( WHILE where_condition DO statement_list? END WHILE
		-> ^( WHILE where_condition statement_list?  ) )
	;

create_procedure
	: CREATE ( DEFINER EQUALS ( user_specification | CURRENT_USER ))? 
		PROCEDURE simple_obj_ref_no_alias LPAREN ( parm+=proc_parameter ( COMMA parm+=proc_parameter )* )? RPAREN 
		( routine_characteristic )* routine_body
		-> ^( CREATE PROCEDURE ( DEFINER user_specification? CURRENT_USER? )? 
			simple_obj_ref_no_alias? $parm* ^( CHARACTERISTIC routine_characteristic* )? routine_body
			)
	;

create_function
	: CREATE ( DEFINER EQUALS ( user_specification | CURRENT_USER ))? 
		FUNCTION simple_obj_ref_no_alias LPAREN ( parm+=func_parameter ( COMMA parm+=func_parameter )* )? RPAREN 
		RETURNS data_type
		( routine_characteristic )* routine_body
		-> ^( CREATE FUNCTION ( DEFINER user_specification? CURRENT_USER? )? 
			simple_obj_ref_no_alias? $parm* RETURNS data_type ^( CHARACTERISTIC routine_characteristic* )? routine_body
			) 
	;

proc_parameter
	:	( type=IN | type=OUT | type=INOUT )? ident data_type	
			-> ^( PARAM ident data_type $type? )
	;

func_parameter
	:	ident data_type	-> ^( PARAM ident data_type )
	;

routine_characteristic
	:	COMMENT STRING_LEX	-> ^( COMMENT STRING_LEX )
	|	LANGUAGE SQL	-> ^( LANGUAGE )
	|	NOT? DETERMINISTIC	-> ^( DETERMINISTIC NOT? )
	|	( ( CONTAINS SQL ) -> ^( CONTAINS )
		| ( NO SQL ) -> ^( NO )
		| ( READS SQL DATA ) -> ^( READS )
		| ( MODIFIES SQL DATA ) -> ^( MODIFIES ))
		
	|	SQL SECURITY ( DEFINER | INVOKER )	-> ^( SQL SECURITY DEFINER? INVOKER? )
	;

routine_body
	:	statement	-> statement	
	;

if_stmt
	:	IF cond+=where_condition THEN condstmt+=statement_list
		elseif_stmt*
		( ELSE elsestmt=statement_list )?
		END IF
		->	^( IF ^( IF_COND $cond? ^( THEN $condstmt* ) ) elseif_stmt*
			^( ELSE $elsestmt)? )
	;

elseif_stmt
	: ELSEIF elifcond=where_condition THEN elifcondstmt=statement_list
		-> ^( ELSEIF $elifcond? ^( THEN $elifcondstmt? ))
	;

/* has to be within a loop, repeat or while statements */
iterate
	:	ITERATE ident	-> ^( ITERATE ident )
	;

/* has to be within a begin-end, loop, repeat or while statements */
leave
	:	LEAVE ident		-> ^( LEAVE ident )
	;

declare_stmt options { backtrack=true; memoize=true; }
	:	DECLARE ids+=ident ( COMMA ids+=ident )* data_type ( DEFAULT defaultexpr=expr )?
		-> ^( DECLARE $ids* data_type? ^( DEFAULT $defaultexpr )? )
	;

set_stmt
	:	SET variable_assignment ( COMMA variable_assignment )*	-> ^( SET variable_assignment+ )
	|	SET ( charset_def | DEFAULT ) -> ^( SET CHARACTER charset_def? DEFAULT? )
	|	SET NAMES ( ( ( val=ID | val=STRING_LEX ) collate?	) | DEFAULT )
		-> ^( SET NAMES $val? COLLATE collate? DEFAULT? )
	;

variable_assignment
	:
	session_variable EQUALS expr	-> 
		^( VAR_ASSIGN /* creating a synthetic root (VAR_ASSIGN) to make antlr generate 
						NextTree() call instead of NextNode() when adding 'session_variable' 
						to the AST */ session_variable expr )
	/* TODO validate vs. the list of system variables */
	|   global_variable EQUALS expr -> ^( VAR_ASSIGN global_variable expr )
	|	( GLOBAL ) => GLOBAL ID EQUALS expr  -> ^( VAR_ASSIGN GLOBAL { new CommonTree( new CommonToken( ID, "@@" + $ID.Text ) ) } expr  )
	|	( SESSION ) => SESSION ID EQUALS expr -> ^( VAR_ASSIGN SESSION { new CommonTree( new CommonToken( ID, "@" + $ID.Text ) ) } expr )
	//|	AT1 AT1 GLOBAL DOT ID EQUALS expr -> ^( VAR_ASSIGN GLOBAL { new CommonTree( new CommonToken( ID, "@@" + $ID.Text ) ) } expr )
	//|   AT1 AT1 SESSION DOT ID EQUALS expr	-> ^( VAR_ASSIGN SESSION { new CommonTree( new CommonToken( ID, "@" + $ID.Text ) ) } expr )
	|	simple_obj_ref_no_alias EQUALS expr	-> ^( VAR_ASSIGN simple_obj_ref_no_alias expr )
	;

session_variable
	:	AT1 ID	->	^( SESSION { new CommonTree( new CommonToken( ID, "@" + $ID.Text ) ) } )
	|	AT1 AT1 SESSION DOT ID -> ^( SESSION { new CommonTree( new CommonToken( ID, "@" + $ID.Text ) ) } )
	;

global_variable
	:	AT1 AT1 ID -> ^( GLOBAL { new CommonTree( new CommonToken( ID, "@@" + $ID.Text ) ) } )
	|	AT1 AT1 GLOBAL DOT ID -> ^( GLOBAL { new CommonTree( new CommonToken( ID, "@@" + $ID.Text ) ) } )
	;

create_database
	:	CREATE ( DATABASE | SCHEMA ) ( IF NOT EXISTS )? ident create_specification* 
		-> ^(CREATE { new CommonTree( new CommonToken( DATABASE, "DATABASE" ) ) } ident)
	;

/* This only for functions, must be at least one, not allowed for procedures or triggers. */
return_stmt
	:	RETURN expr	-> ^( RETURN expr )	
	;

do_stmt	:	DO exprList		-> ^(DO exprList)
	;

show_stmt 
  : (SHOW -> ^(SHOW))
    ( AUTHORS     -> ^($show_stmt ^(AUTHORS))
    | BINLOG EVENTS (IN logName=STRING_LEX)? (FROM INT_NUMBER)? limit?  -> ^($show_stmt ^(BINLOG $logName? INT_NUMBER? limit?))
    | CHARACTER SET like_or_where?  -> ^($show_stmt ^(CHARACTER like_or_where?))
    | COLLATION like_or_where?    -> ^($show_stmt ^(COLLATION like_or_where?))
	| COUNT LPAREN MULT RPAREN WARNINGS		-> ^( $show_stmt ^( COUNT WARNINGS ) )
    | FULL? COLUMNS (FROM|IN) simple_table_ref_no_alias ((FROM|IN) ident)? like_or_where? -> ^($show_stmt ^(COLUMNS FULL? simple_table_ref_no_alias ident? like_or_where?))
    | CONTRIBUTORS  -> ^($show_stmt ^(CONTRIBUTORS))    
	| CREATE DATABASE ident -> ^($show_stmt ^(CREATE DATABASE ident))
    | CREATE EVENT ident    -> ^($show_stmt ^(CREATE EVENT ident))
    | CREATE FUNCTION ident -> ^($show_stmt ^(CREATE FUNCTION ident))
    | CREATE PROCEDURE ident  -> ^($show_stmt ^(CREATE PROCEDURE ident))
    | CREATE TABLE simple_table_ref_no_alias_existing  -> ^($show_stmt ^(CREATE TABLE simple_table_ref_no_alias_existing))
    | CREATE TRIGGER ident  -> ^($show_stmt ^(CREATE TRIGGER ident))
    | CREATE VIEW ident   -> ^($show_stmt ^(CREATE VIEW ident))
    | DATABASES like_or_where?  -> ^($show_stmt ^(DATABASES like_or_where?))
    | ENGINE (INNODB | ident) (what=STATUS | what=MUTEX) // have to add INNODB token, because of SHOW INNODB STATUS :(
                    -> ^($show_stmt ^(ENGINE INNODB? ident? $what))
    | STORAGE? ENGINES    -> ^($show_stmt ^(ENGINES))
    | ERRORS limit?     -> ^($show_stmt ^(ERRORS limit?))
    | FULL? EVENTS      -> ^($show_stmt ^(EVENTS FULL?))
    | FUNCTION CODE ident   -> ^($show_stmt ^(CODE FUNCTION ident))
    | FUNCTION STATUS like_or_where?  -> ^($show_stmt ^(STATUS FUNCTION like_or_where?))
    | GRANTS FOR
        ( 		  
		  STRING_LEX user_host?
		| ID user_host?
        | whom+=CURRENT_USER
        | whom+=CURRENT_USER LPAREN RPAREN
        )         -> ^($show_stmt ^(GRANTS $whom? ID? STRING_LEX? user_host? ))
    | INDEX FROM simple_table_ref_no_alias ((FROM|IN) ident)? -> ^($show_stmt ^(INDEX simple_table_ref_no_alias ident?))
	/* This is deprecated in MySql 5.1 */
    | innodb_status -> ^( $show_stmt innodb_status )
    | OPEN TABLES ((FROM|IN) ident)? like_or_where? -> ^($show_stmt ^(OPEN ident? like_or_where?))
    | plugins -> ^( $show_stmt plugins )
    | PROCEDURE CODE ident      -> ^($show_stmt ^(CODE PROCEDURE ident))
    | PROCEDURE STATUS like_or_where? -> ^($show_stmt ^(STATUS PROCEDURE ident))
    | PRIVILEGES      -> ^($show_stmt ^(PRIVILEGES))
    | FULL? PROCESSLIST -> ^($show_stmt ^(PROCESSLIST FULL?))
    | ( PROFILE | PROFILES ) ( show_profile_types ( COMMA show_profile_types )* )? (FOR QUERY INT_NUMBER)? limit? -> ^($show_stmt ^( { new CommonTree( new CommonToken( PROFILE, "PROFILE" ) ) }  show_profile_types* INT_NUMBER? limit?))
    /*| PROFILES    -> ^($show_stmt ^(PROFILES)) */
    | SCHEDULER STATUS  -> ^($show_stmt ^(STATUS SCHEDULER))
    | optScopeModifier STATUS like_or_where?  -> ^($show_stmt ^(STATUS optScopeModifier? like_or_where?))
    | TABLE STATUS ((FROM|IN) ident)? like_or_where?      -> ^($show_stmt  ^(STATUS TABLE ident? like_or_where?))
    | FULL? TABLES ((FROM|IN) ident)? like_or_where?          -> ^($show_stmt ^(TABLES FULL? ident? like_or_where?))
    | TRIGGERS ((FROM|IN) ident)? like_or_where?        -> ^($show_stmt ^(TRIGGERS ident? like_or_where?))
    | optScopeModifier VARIABLES like_or_where?   -> ^($show_stmt ^(VARIABLES optScopeModifier? like_or_where?))
    | WARNINGS limit?   -> ^($show_stmt ^(WARNINGS limit?))
	| SLAVE HOSTS -> ^($show_stmt ^(SLAVE HOSTS))
	| SLAVE STATUS -> ^($show_stmt ^(SLAVE STATUS))
	| MASTER STATUS -> ^($show_stmt ^(MASTER STATUS))
	| BINARY LOGS -> ^($show_stmt ^(BINARY LOGS))
	| MASTER LOGS -> ^($show_stmt ^(MASTER LOGS))	
    )
  ;

innodb_status
  : { this.mysqlVersion <= 5.1 }? =>  INNODB STATUS   -> ^( INNODB STATUS )
  ;

plugins
  : { this.mysqlVersion >= 5.1 }? => PLUGINS    -> ^( PLUGINS )
  ;

create_specification
  : ( DEFAULT )? charset_equals
  | ( DEFAULT )? collate_equals
  ;

optScopeModifier
  : GLOBAL    -> GLOBAL
  | SESSION   -> SESSION
  | l=LOCAL   -> SESSION[$l]
  | /* empty, defaults to SESSION */ -> SESSION
  ;

show_profile_types
  : ALL
  | BLOCK IO
  | CONTEXT SWITCHES
  | CPU
  | IPC
  | MEMORY
  | PAGE FAULTS
  | SOURCE
  | SWAPS
  ;

like_or_where
  : // behold, this is a special LIKE...does not allow expressions on the RHS
    LIKE string_or_placeholder   -> ^(LIKE string_or_placeholder)
  | WHERE expr    -> ^(WHERE expr)
  ;
  
explain
  : EXPLAIN ( EXTENDED | explain_partitions | explain_type )? ( select_inner | explain_stmt )
	-> ^( EXPLAIN select_inner? explain_stmt? )  
	| EXPLAIN simple_table_ref_alias -> ^( EXPLAIN simple_table_ref_alias )
  ;

explain_partitions
  : { this.mysqlVersion >= 5.1 }? => PARTITIONS
  ;

explain_type
  : { this.mysqlVersion >= 5.6 }? => FORMAT EQUALS ( TRADITIONAL | JSON )
  ;

explain_stmt
  : { this.mysqlVersion >= 5.6 }? => ( delete | insert | replace | update )
  ;

help
	:	HELP STRING_LEX	-> ^( HELP STRING_LEX )
	;

use
	:	USE ID	-> ^( USE ID )
	;

describe
	:	( DESCRIBE | DESC ) tblname=ID ( col=ID | wild=STRING_LEX )
			-> ^( { new CommonTree( new CommonToken( DESCRIBE, "DESCRIBE" ) ) } $tblname $col? $wild? )
	;

prepare
	:	PREPARE stmtname=ID FROM prepstmt=session_variable
			-> ^( PREPARE $stmtname $prepstmt )
	;

deallocate
	:	( DEALLOCATE | DROP ) PREPARE ID	-> 
		^( { new CommonTree( new CommonToken( DEALLOCATE, "DEALLOCATE" ) ) } ID ) 
	;

// Cursors
cursor_close
	:	CLOSE ID	-> ^( CLOSE ID )
	;

cursor_declare
	:	DECLARE ID CURSOR FOR select	-> ^( DECLARE CURSOR ID select )
	;

cursor_fetch
	:	FETCH curname=ID INTO vars+=ID ( COMMA vars+=ID )*
			-> ^( FETCH $curname INTO $vars*  )
	;
	 
cursor_open
	:	OPEN ID	-> ^( OPEN ID )
	;

execute
	:	EXECUTE ID ( USING vars+=session_variable ( COMMA vars+=session_variable )* )?	
			->	^( EXECUTE ID $vars? ) 
	;

select
@init {
bool seenUnion = false;
}
	:	select_paren
		( ( UNION ) => (UNION (mod=ALL | mod=DISTINCT)? union_selects+=select {seenUnion=true;}))*
		 	-> {seenUnion}? ^(UNION $mod? select_paren $union_selects+)
			-> select_paren
	;

select_paren 
	:	LPAREN select_paren RPAREN	 -> select_paren
	|	select_inner 	-> select_inner
	;
	catch[ NoViableAltException nvae ] 
	{
		if( nvae.DecisionNumber == 121 )
		{
			nvae = new NoViableAltException( 
					"column_name", 
					nvae.DecisionNumber, 
					0 /* re.StateNumber*/, 
					nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

select_inner 
	:	( 
		SELECT  
		(( ALL | DISTINCT | DISTINCTROW | HIGH_PRIORITY | STRAIGHT_JOIN | SQL_SMALL_RESULT | SQL_BIG_RESULT | 
		  SQL_BUFFER_RESULT | SQL_CACHE | SQL_NO_CACHE | SQL_CALC_FOUND_ROWS  ) => select_options)*
		exprs+=select_expr (COMMA exprs+=select_expr)*
		//( 
			select_into_from
            (forUpdate=FOR UPDATE | clock=LOCK IN SHARE MODE)?         
		//)?
		)
		-> ^(SELECT 
				^(OPTIONS select_options*)?
				^(COLUMNS $exprs+)
				select_into_from	
				$forUpdate?
				$clock?
			)
	;
	catch[ NoViableAltException nvae ] 
	{
		//if( nvae.Token.Text == "<EOF>" ) {
			nvae = new NoViableAltException( 
				"column_name", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		//}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}	

select_into_from options { backtrack=true; }
	:	( order_by? limit?			-> ^( INTO_FROM order_by? limit? ) )
	/*|	select_into					-> ^( INTO_FROM select_into )
	|	select_from					-> ^( INTO_FROM select_from ) */
	|	( select_into select_from? /*( { input.LA( 1 ) == FROM }? select_from )?	*/
			-> ^( INTO_FROM select_into select_from? ) )
	|	( select_from select_into?	-> ^( INTO_FROM select_from select_into? ) )
	;

select_into
	:	INTO 
			(
				OUTFILE file=STRING_LEX opts=infile_options_helper
            |	DUMPFILE file=STRING_LEX
            |	vars+=variable (COMMA vars+=variable)*
            )
		-> ^( INTO $file? $opts? $vars? )?
	;

select_from
	:	FROM table_references
            (WHERE where=where_condition)?
            ( group_by )?
            (HAVING having=where_condition)?
            order_by?
            limit?
            // these procedures are not "SQL-SPs" but C++ ones. very unlikely that we'll see them.
            (PROCEDURE procId=ident procArgs=parenOptExprList)?
		-> ^(FROM table_references ^(WHERE $where)? group_by? ^(HAVING $having)? )?
	;

infile_options_helper
	:	(	(COLUMNS|FIELDS)
			(TERMINATED BY fieldTerm=STRING_LEX)?
			(optEnclosed=OPTIONALLY? ENCLOSED BY fieldEncl=STRING_LEX)?			/* TODO: STRING here is one character, really */
			(ESCAPED BY fieldEsc=STRING_LEX)?									/* TODO: STRING here is one character, really */
		)?
		(	LINES
			(STARTING BY linesStart=STRING_LEX)?
			(TERMINATED BY linesTerm=STRING_LEX)?
		)?
	;
	
variable
	:	session_variable	-> ^( VAR session_variable )
	|	global_variable		-> ^( VAR global_variable )
	|	ID					-> ^( VAR ID )
	;

limit
	:	LIMIT
			(	((offset=number_or_placeholder COMMA)? lim=number_or_placeholder)	
			| 	(lim=number_or_placeholder offsetForm=OFFSET offset=number_or_placeholder)
			)
		-> ^(LIMIT $lim $offset? $offsetForm?)
	;

string_or_placeholder
	:	STRING_LEX
	|	VALUE_PLACEHOLDER
	;

number_or_placeholder
	:	INT_NUMBER
	|	VALUE_PLACEHOLDER
	;

text_string
	:	STRING_LEX
	|	BINARY_VALUE
	|	HEXA_VALUE
	;

group_by
	:	GROUP BY 
			elements+=order_group_by_elements (COMMA elements+=order_group_by_elements )*
		(rollup=WITH ROLLUP)?
		-> ^(GROUP $elements+ $rollup?)
	;

order_by
	:	ORDER BY
			elements+=order_group_by_elements (COMMA elements+=order_group_by_elements )*
		-> ^(ORDER $elements+)
	;
	
order_group_by_elements
	:	expr 
		(	asc=ASC						-> ^(DIRECTION[$asc] expr)
		|	desc=DESC					-> ^(DIRECTION[$desc] expr)
		|	/* implicit ASC */			-> ^(DIRECTION["ASC"] expr)
		)
	;

select_options
	:
	(	ALL
	|	DISTINCT
	|	DISTINCTROW
	|	HIGH_PRIORITY
	|	STRAIGHT_JOIN
	|	SQL_SMALL_RESULT
	|	SQL_BIG_RESULT
	|	SQL_BUFFER_RESULT
	|	SQL_CACHE
	|	SQL_NO_CACHE
	|	SQL_CALC_FOUND_ROWS )
	;
	
select_expr
	:	( star=MULT				-> ^(SELECT_EXPR $star) )
	|	expr 
	(
		( { input.LA(1) == AS }? => (AS (ident | STRING_LEX) ))
	|	( { input.LA(1) == ID }? => (ID)
								-> ^(SELECT_EXPR expr ^(ALIAS ident? STRING_LEX?)?) )
	|	( -> ^( SELECT_EXPR expr ))
	)
	;
	catch[ NoViableAltException nvae ] 
	{
		nvae = new NoViableAltException( 
			"column_name", 
			nvae.DecisionNumber /* re.DecisionNumber */, 
			0 /* re.StateNumber*/, 
			nvae.Input );		
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

/*	catch[RecognitionException re] {
	   Object errorNode = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
	   Object root_1 = (Object)adaptor.nil();
     root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECT_EXPR, "SELECT_EXPR"), root_1);
     adaptor.addChild(root_1, errorNode);
     adaptor.addChild(root_0, root_1);
     retval.tree = (Object)adaptor.rulePostProcessing(root_0);
	}
*/
table_references returns [int table_count]
scope {
int count;
}
@init {
$table_references::count = 0;
}
@after {
$table_references.table_count = $table_references::count;
}
	:	(	t1=table_ref 			-> $t1)
		(	COMMA t2=table_ref		-> ^(COMMA_JOIN[$COMMA] $table_references $t2)
		)*
	;

/* left factored to get rid of the recursion */
table_ref
	:	(t1=table_factor -> $t1 )
		(
			((LEFT|RIGHT)=>((ltype=LEFT|ltype=RIGHT) outer=OUTER? JOIN t3=table_ref lrjoinCond=join_condition_both 
				-> ^($ltype {$tree} $t3 $lrjoinCond $outer?)))
		|	((type=INNER|type=CROSS)? JOIN t2=table_factor ( options {greedy = true;}:cond1=join_condition_both )? 
				-> ^(JOIN {$tree} $t2 $cond1? $type?))
		|	((	type=STRAIGHT_JOIN t2=table_factor 
				(	(join_condition_on)=> cond2=join_condition_on	-> ^($type {$tree} $t2 $cond2)
				|							-> ^($type {$tree} $t2)
				)
			))
		|	((NATURAL)=> NATURAL ((type=LEFT|type=RIGHT) outer=OUTER?)? JOIN t2=table_factor -> ^(NATURAL $type? {$tree} $t2 $outer?))
		)*
	;
	
table_factor
scope
{
	bool isSelectSeen;
}
@init { $table_factor::isSelectSeen = IsSelectSeen(); }
	:	( simple_table_ref_alias_with_partition index_hint_list? {$table_references::count++;} -> ^(TABLE simple_table_ref_alias_with_partition index_hint_list?) )
	| ( { !$table_factor::isSelectSeen }? ( ( LPAREN ) => ( LPAREN table_ref RPAREN ) ) -> ^( TABLE table_ref ) ) 
	| ( ( LPAREN ) => LPAREN select RPAREN AS? ident		{$table_references::count++;} -> 
		^(SUBSELECT select ^(ALIAS ident)) )     //|   LPAREN table_ref {$table_references::count++;} (COMMA table_ref {$table_references::count++;} )* RPAREN   -> ^(TABLE table_ref+)
	/* ident in the following should really by 'OJ', but the parser accepts any identifier in its place 
	|	LCURLY ident t1=table_ref LEFT OUTER JOIN t2=table_ref join_condition_on RCURLY 
			-> ^(ident $t1 $t2 join_condition_on) */
	/* The definition the syntax for ODBC is taken from the rule 'esc_table_ref' in file sql_yacc.yy,
		the previously commented out definition is ambiguous with table_ref rule.
	 */
	| LCURLY ident table_ref RCURLY			-> ^(TABLE table_ref)
	|	DUAL								-> ^(DUAL)
	;
	catch[ NoViableAltException nvae ] 
	{
		nvae = new NoViableAltException( 
				( new System.Diagnostics.StackTrace( true ).GetFrame( 0 ).GetMethod().GetCustomAttributes(true)[ 0 ] as 
				GrammarRuleAttribute ).Name, 0/* nvae.DecisionNumber */, 0 /* nvae.StateNumber*/, nvae.Input );		
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

join_condition_on
	:	ON where_condition		-> ^(ON where_condition)
	;

join_condition_both
	:	( ( ON ) => join_condition_on -> join_condition_on )
	|	(USING LPAREN fields+=ident (COMMA fields+=ident)* RPAREN		-> ^(USING $fields+))
	;

simple_obj_ref_no_alias
	:	first=ident (DOT second=ident)?		-> ^( $first $second? )
	/*|	DOT ident					/* TODO: No AST for this subrule? */
	;

simple_table_ref_no_alias
	:	first=ident (DOT second=ident)?		-> ^( TABLE_REF $first? $second? )
	;

simple_table_ref_no_alias_existing
	:	simple_table_ref_no_alias	-> simple_table_ref_no_alias
	;

simple_table_ref_alias_with_partition
	:	first=ident (DOT second=ident)? partition_ref? table_alias?		-> ^( TABLE_REF $first? $second? table_alias? )
	;

simple_table_ref_alias
	:	first=ident (DOT second=ident)? table_alias?		-> ^( TABLE_REF $first? $second? table_alias? )
	;

table_alias
	:	( { input.LA(1) == AS }? ( AS alias=ident )	-> ^(ALIAS $alias) )
	|	( { input.LA(1) != AS }? alias=ident	-> ^(ALIAS $alias) )
	;

field_name
@init {
int i = 0;
bool seenStar = false;
}
	:	ident
		({seenStar == false}?=> 
		  (DOT 
		    ({seenStar == false}? (ident | star=MULT {seenStar = true;}) {++i <= 2}?)
		  )*
		)
		-> ^(FIELD ident+ $star?)//	|	(DOT)=>DOT column=field_name_column	-> ^(FIELD $column)
	;

/* list all keywords that can also be used as an identifier
   This list is taken from the 5.1 YACC grammar 
*/

ident options { backtrack=true; memoize=true; }
	:
	(
	tok=ID
|	tok= ASCII             
|   tok= BACKUP            
|   ( { _blockStack.Peek() != BlockKind.BeginEnd }? => tok= BEGIN )
|   tok= BYTE              
|   tok= CACHE             
|   tok= CHARSET               
|   tok= CHECKSUM          
|   tok= CLOSE             
|   tok= COMMENT           
|   tok= COMMIT            
|   tok= CONTAINS          
|   tok= DEALLOCATE        
|   tok= DO                
|   ( { _blockStack.Peek() != BlockKind.BeginEnd }? => tok= END )
|   tok= EXECUTE           
|   tok= FLUSH             
|   tok= FORMAT            
|   tok= HANDLER           
|   tok= HELP              
|   tok= HOST              
|   tok= INSTALL           
|   tok= LANGUAGE          
|   tok= NO                
|   tok= OPEN              
|   tok= OPTIONS           
|   tok= OWNER             
|   tok= PARSER            
|   tok= PORT              
|   tok= PREPARE           
|   tok= REMOVE            
|   tok= REPAIR                
|   tok= RESET             
|   tok= RESTORE           
|   tok= ROLLBACK          
|   tok= SAVEPOINT         
|   tok= SECURITY          
|   tok= SERVER            
|   tok= SIGNED            
|   tok= SOCKET            
|   tok= SLAVE                 
|   tok= SONAME            
|   tok= START             
|   tok= STOP              
|   tok= TRUNCATE          
|   tok= UNICODE           
|   tok= UNINSTALL         
|   tok= WRAPPER           
|   tok= XA                
|   tok= UPGRADE           
	)	-> ID[$tok] 
	|	ident_sp_label_internal	-> {$ident_sp_label_internal.tree}
	;
	catch[ NoViableAltException nvae ] 
	{
		if( simple_table_ref_no_alias_existing_cnt > 0 )
		{
			nvae = new NoViableAltException( 
				"simple_table_ref_no_alias_existing", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		} else if( Scope.Peek() == "field_name" ) {
			nvae = new NoViableAltException( 
				"column_name", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}	

ident_sp_label
	: ID | ident_sp_label_internal
	;

ident_sp_label_internal
	:		
	(	/*tok=ID!*/
    	tok=ACTION!
    |	tok=ADDDATE!
    |	tok=AFTER!
    |	tok=AGAINST!
    |	tok=AGGREGATE!
    |	tok=ALGORITHM!
	|	tok=ANALYSE!
    |	tok=ANY!
    |	tok=AT!
    |	tok=AUTO_INCREMENT!
    |	tok=AUTOEXTEND_SIZE!
    |	tok=AVG_ROW_LENGTH!
    |	tok=AVG!
    |	tok=BINLOG!
    |	tok=BIT!
    |	tok=BLOCK!
    |	tok=BOOL!
    |	tok=BOOLEAN!
    |	tok=BTREE!
    |	tok=CASCADED!
	|	tok=CATALOG_NAME!
    |	tok=CHAIN!
    |	tok=CHANGED!
    |	tok=CIPHER!
    |	tok=CLIENT!
	|	tok=CLASS_ORIGIN!
    |	tok=COALESCE!
    |	tok=CODE!
    |	tok=COLLATION!
	|	tok=COLUMN_FORMAT!
	|	tok=COLUMN_NAME!
    |	tok=COLUMNS!
    |	tok=COMMITTED!
    |	tok=COMPACT!
    |	tok=COMPLETION!
    |	tok=COMPRESSED!
    |	tok=CONCURRENT!
    |	tok=CONNECTION!
    |	tok=CONSISTENT!
	|	tok=CONTRAINT_CATALOG!
	|	tok=CONSTRAINT_SCHEMA!
	|	tok=CONSTRAINT_NAME!
    |	tok=CONTEXT!
    |	tok=CPU!
    |	tok=CUBE!
	|	tok=CURRENT!
	|	tok=CURSOR_NAME!
    |	tok=DATA!
    |	tok=DATAFILE!
    |	tok=DATETIME!
	|	tok=DATE!
    |	tok=DAY!
	|	tok=DEFAULT_AUTH!
    |	tok=DEFINER!
    |	tok=DELAY_KEY_WRITE!
    |	tok=DES_KEY_FILE!
	|	tok=DIAGNOSTICS!
    |	tok=DIRECTORY!
    |	tok=DISABLE!
    |	tok=DISCARD!
    |	tok=DISK!
    |	tok=DUMPFILE!
    |	tok=DUPLICATE!
    |	tok=DYNAMIC!
	|	tok=ENABLE!
    |	tok=ENDS!
    |	tok=ENUM!
    |	tok=ENGINE!
    |	tok=ENGINES!
	|	tok=ERROR!
    |	tok=ERRORS!
    |	tok=ESCAPE!
    |	tok=EVENT!
    |	tok=EVENTS!
    |	tok=EVERY!
	|	tok=EXCHANGE!
    |	tok=EXPANSION!
	|	tok=EXPIRE!
	|	tok=EXPORT!
    |	tok=EXTENDED!
    |	tok=EXTENT_SIZE!
    |	tok=FAULTS!
    |	tok=FAST!
    |	tok=FILE!
    |	tok=FIRST!
    |	tok=FIXED!
    |	tok=FOUND!    
    |	tok=FULL!
	|   tok=FUNCTION!       
	|	tok=GENERAL!
    |	tok=GEOMETRY!
    |	tok=GEOMETRYCOLLECTION!
    |	tok=GET_FORMAT!
    |	tok=GRANTS!
    |	tok=GLOBAL!
    |	tok=HASH!
    |	tok=HOSTS!
    |	tok=HOUR!
    |	tok=IDENTIFIED!
	|	tok=IGNORE_SERVER_IDS!
    |	tok=INVOKER!
    |	tok=IMPORT!
    |	tok=INDEXES!
    |	tok=INITIAL_SIZE!
    |	tok=IO!
    |	tok=IPC!
    |	tok=ISOLATION!
    |	tok=ISSUER!
    |	tok=INSERT_METHOD!
    |	tok=KEY_BLOCK_SIZE!
    |	tok=LAST!
    |	tok=LEAVES!
    |	tok=LESS!
    |	tok=LEVEL!
    |	tok=LINESTRING!
    |	tok=LIST!
    |	tok=LOCAL!
    |	tok=LOCKS!
    |	tok=LOGFILE!
    |	tok=LOGS!
    |	tok=MAX_ROWS!
    |	tok=MASTER!
    |	tok=MASTER_HEARTBEAT_PERIOD!
    |   tok= MASTER_HOST!          
    |   tok= MASTER_PORT!          
    |   tok= MASTER_LOG_FILE!      
    |   tok= MASTER_LOG_POS!       
    |   tok= MASTER_USER!          
    |   tok= MASTER_PASSWORD!      
    |   tok= MASTER_SERVER_ID!     
    |   tok= MASTER_CONNECT_RETRY! 
    |   tok= MASTER_RETRY_COUNT!   
    |   tok= MASTER_DELAY!         
    |   tok= MASTER_SSL!           
    |   tok= MASTER_SSL_CA!        
    |   tok= MASTER_SSL_CAPATH!    
    |   tok= MASTER_SSL_CERT!      
    |   tok= MASTER_SSL_CIPHER!    
    |   tok= MASTER_SSL_CRL!       
    |   tok= MASTER_SSL_CRLPATH!   
    |   tok= MASTER_SSL_KEY!       
    |   tok= MASTER_AUTO_POSITION! 
    |   tok= MAX_CONNECTIONS_PER_HOUR!
    |   tok= MAX_QUERIES_PER_HOUR!
    |   tok= MAX_SIZE!             
    |   tok= MAX_UPDATES_PER_HOUR!
    |   tok= MAX_USER_CONNECTIONS! 
    |   tok= MEDIUM!               
    |   tok= MEMORY!               
    |   tok= MERGE!                
    |   tok= MESSAGE_TEXT!         
    |   tok= MICROSECOND!          
    |   tok= MIGRATE!              
    |   tok= MINUTE!               
    |   tok= MIN_ROWS!
    |   tok= MODIFY!               
    |   tok= MODE!                 
    |   tok= MONTH!                
    |   tok= MULTILINESTRING!
    |   tok= MULTIPOINT!
    |   tok= MULTIPOLYGON!
    |   tok= MUTEX!                
    |   tok= MYSQL_ERRNO!          
    |   tok= NAME!                 
    |   tok= NAMES!                
    |   tok= NATIONAL!             
    |   tok= NCHAR!                
    |   tok= NDBCLUSTER!           
    |   tok= NEXT!                 
    |   tok= NEW!                  
    |   tok= NO_WAIT!              
    |   tok= NODEGROUP!            
    |   tok= NONE!                 
    |   tok= NNUMBER!
    |   tok= NVARCHAR!
    |   tok= OFFSET!
    |   tok= OLD_PASSWORD!
    |   tok= ONE!                  
    |   tok= ONLY!                 
    |   tok= PACK_KEYS!            
    |   tok= PAGE!                 
    |   tok= PARTIAL!
    |   tok= PARTITIONING!         
    |   tok= PARTITIONS!           
    |   tok= PASSWORD!
    |   tok= PHASE!                
    |   tok= PLUGIN_DIR!           
    |   tok= PLUGIN!               
    |   tok= PLUGINS!              
    |   tok= POINT!                
    |   tok= POLYGON!
    |   tok= PRESERVE!             
    |   tok= PREV!                 
    |   tok= PRIVILEGES!
    |   tok= PROCESS!
    |   tok= PROCESSLIST!          
    |   tok= PROFILE!              
    |   tok= PROFILES!             
    |   tok= PROXY!                
    |   tok= QUARTER!              
    |   tok= QUERY!                
    |   tok= QUICK!
    |   tok= READ_ONLY!            
    |   tok= REBUILD!              
    |   tok= RECOVER!              
    |   tok= REDO_BUFFER_SIZE!     
    |   tok= REDOFILE!             
    |   tok= REDUNDANT!            
    |   tok= RELAY!
    |   tok= RELAYLOG!             
    |   tok= RELAY_LOG_FILE!       
    |   tok= RELAY_LOG_POS!        
    |   tok= RELAY_THREAD!
    |   tok= RELOAD!
    |   tok= REORGANIZE!           
    |   tok= REPEATABLE!           
    |   tok= REPLICATION!
    |   tok= RESOURCES!
    |   tok= RESUME!               
    |   tok= RETURNED_SQLSTATE!    
    |   tok= RETURNS!              
    |   tok= REVERSE!              
    |   tok= ROLLUP!               
    |   tok= ROUTINE!              
    |   tok= ROWS!                 
    |   tok= ROW_COUNT!            
    |   tok= ROW_FORMAT!           
    |   tok= ROW!                  
    |   tok= RTREE!                
    |   tok= SCHEDULE!             
    |   tok= SCHEMA_NAME!          
    |   tok= SECOND!               
    |   tok= SERIAL!               
    |   tok= SERIALIZABLE!         
    |   tok= SESSION!              
    |   tok= SIMPLE!               
    |   tok= SHARE!                
    |   tok= SHUTDOWN!
    |   tok= SLOW!
    |   tok= SNAPSHOT!             
    |   tok= SOUNDS!               
    |   tok= SOURCE!               
    |   tok= SQL_AFTER_GTIDS!
    |   tok= SQL_AFTER_MTS_GAPS!
    |   tok= SQL_BEFORE_GTIDS!
    |   tok= SQL_CACHE!            
    |   tok= SQL_BUFFER_RESULT!
    |   tok= SQL_NO_CACHE!         
    |   tok= SQL_THREAD!
    |   tok= STARTS!
    |   tok= STATS_AUTO_RECALC!    
    |   tok= STATS_PERSISTENT!     
    |   tok= STATS_SAMPLE_PAGES!   
    |   tok= STATUS!               
    |   tok= STORAGE!              
    |   tok= STRING_KEYWORD!               
    |   tok= SUBCLASS_ORIGIN!      
    |   tok= SUBDATE!              
    |   tok= SUBJECT!              
    |   tok= SUBPARTITION!         
    |   tok= SUBPARTITIONS!        
    |   tok= SUPER!                
    |   tok= SUSPEND!              
    |   tok= SWAPS!                
    |   tok= SWITCHES!             
    |   tok= TABLE_NAME!           
    |   tok= TABLES!
    |   tok= TABLE_CHECKSUM!       
    |   tok= TABLESPACE!
    |   tok= TEMPORARY!
    |   tok= TEMPTABLE!            
    |   tok= TEXT!                 
    |   tok= THAN!                 
    |   tok= TRANSACTION!          
    |   tok= TRIGGERS!             
    |   tok= TIMESTAMP!
    |   tok= TIMESTAMP_ADD!
    |   tok= TIMESTAMP_DIFF!
    |   tok= TIME!                 
    |   tok= TYPES!                
    |   tok= TYPE!                 
    |   tok= UDF_RETURNS!                    
    |   tok= UNCOMMITTED!          
    |   tok= UNDEFINED!            
    |   tok= UNDO_BUFFER_SIZE!     
    |   tok= UNDOFILE!             
    |   tok= UNKNOWN!              
    |   tok= UNTIL!                
    |   tok= USER!
    |   tok= USE_FRM!
    |   tok= VARIABLES!
    |   tok= VIEW!                 
    |   tok= VALUE!                
    |   tok= WARNINGS!
    |   tok= WAIT!                 
    |   tok= WEEK!                 
    |   tok= WEIGHT_STRING!        
    |   tok= WORK!                 
    |   tok= X509!                 
    |   tok= XML!                  
    |   tok= YEAR!  )               
	{
		adaptor.AddChild(root_0, (object)adaptor.Create(ID, $tok));
	}
	;

index_hint_list
	:	index_hint (COMMA index_hint)*		-> ^(INDEX_HINTS index_hint+)
	;

index_hint
scope {
bool namesOptional;
}
@init {
$index_hint::namesOptional = false;
}
	:	( USE {$index_hint::namesOptional = true;} index_hint_rest		-> ^(USE index_hint_rest) )
	|	( IGNORE {$index_hint::namesOptional = false;} index_hint_rest	-> ^(IGNORE index_hint_rest) )
	|	( FORCE {$index_hint::namesOptional = false;} index_hint_rest	-> ^(FORCE index_hint_rest) )
	;

index_hint_rest
	:	(name=INDEX|name=KEY) (FOR (usage=JOIN | usage=ORDER BY | usage=GROUP BY))?
		LPAREN
		( {$index_hint::namesOptional == true}?=> (names+=ident (COMMA names+=ident)*)?
		| names+=ident (COMMA names+=ident)* 
		)
		RPAREN
		-> $name ^(LPAREN $names?) $usage?
	;
// $<Expressions

exprList
	:	e+=expr (COMMA e+=expr)*	-> ^( EXPR_LIST $e+ )
	;

parenExpr
	:	LPAREN expr RPAREN	-> ^(LPAREN expr)
	;
	
parenExprList
	:	LPAREN exprList RPAREN	-> exprList
	;
	
parenOptExprList
	:	LPAREN ( { input.LA( 1 ) != RPAREN }? => e=exprList )? RPAREN	->  ^( PARENT_OPT_EXPR_LIST $e? )
	;

expr
	:	lhs=assignOrExpr (op=ASSIGN^ rhs=expr)?	
	//-> ^( EXPR ^( $op $lhs $rhs ) )
	;

assignOrExpr
	:	lhs=assignXORExpr ((op+=LOGICAL_OR^ | op+=OR^) rhs+=assignXORExpr)*
		//-> ^( ASSIGN_OR_EXPR ^( $op $lhs $rhs ) )
	;

assignXORExpr
	:	lhs=assignAndExpr (op+=XOR^ rhs+=assignAndExpr)*
		//-> ^( ASSIGN_XOR_EXPR ^( $op $lhs $rhs ) )
	;

assignAndExpr
	:	lhs=assignNotExpr (( op+=LOGICAL_AND^ | op+=AND^ ) rhs+=assignNotExpr)*
		//-> ^( ASSIGN_AND_EXPR ^(  $op $lhs $rhs ) )
	;

assignNotExpr
	:	lhs=equalityExpr			/*-> ^( ASSIGN_NOT_EXPR $lhs ) */
	|	op+=NOT^ rhs+=equalityExpr  /*-> ^( ASSIGN_NOT_EXPR ^( $op $rhs ))  */
	;
	catch[ NoViableAltException nvae ] 
	{
		if( Scope.Peek() == "expr" ) {
			nvae = new NoViableAltException( 
				"column_name", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

equalityExpr
	:	bitwiseOrExpr
		(op+=equalityOperator^ ((subselect_in_expr_rhs)=> subselect_in_expr_rhs | bitwiseOrExpr))*		
	;
	catch[ NoViableAltException nvae ] 
	{
		if( ( nvae.DecisionNumber == 203 ) && ( Scope.Peek() == "expr" ))
		{
			nvae = new NoViableAltException( 
				"column_name", 
				nvae.DecisionNumber, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

subselect_in_expr_rhs
	:	(mod=ANY | mod=SOME | mod=ALL) LPAREN select RPAREN	-> ^(SUBSELECT $mod select)
	;
	
subselect
	:	LPAREN select_inner RPAREN	-> ^(SUBSELECT select_inner)
	;

isOperator
	:	IS NOT? (value2=NULL | value2=FALSE | value2=TRUE | value2=UNKNOWN)	-> ^(IS NOT? $value2)
	;

equalityOperator
	:	(	value=EQUALS
		|	value=NOT_EQUAL
		|	value=LESS_THAN
		|	value=LESS_THAN_EQUAL
		|	value=GREATER_THAN
		| 	value=GREATER_THAN_EQUAL
		|	value=NULL_SAFE_NOT_EQUAL
		| 	value=REGEXP
		|	value=BETWEEN
		/*		
		|	value=CASE
		|	value=WHEN
		|	value=THEN
		|	value=ELSE
		*/
		) -> $value
	;

bitwiseOrExpr
  : lhs=bitwiseAndExpr 
	( ( BITWISE | NOT | IN | LIKE | BETWEEN | SOUNDS | IS ) =>
    ( (op+=BITWISE_OR^ rhs+=bitwiseAndExpr)+ 
    | ((NOT^)? IN^ (parenExprList | subselect)) 
    | (LIKE^ unaryExpr (ESCAPE STRING_LEX)? ) // STRING must be empty or one character long (or be "\\" if not in sql_mode NO_BACKSLASH_ESCAPES)		
	| (BETWEEN^ bitwiseAndExpr AND! bitwiseOrExpr )
	| (SOUNDS^ LIKE bitwiseAndExpr)
    | isOperator^
    ))? 
  ;

bitwiseAndExpr
	:	lhs=shiftExpr (op+=BITWISE_AND^ rhs+=shiftExpr)*
	;

shiftExpr
	:	lhs=additiveExpr ((op+=LEFT_SHIFT^ | op+=RIGHT_SHIFT^) rhs+=additiveExpr)*
	;

/* this is ugly because of INTERVAL:
   As rightmost in an expression, it has the highest precendence.
   Otherwise it must be followed by PLUS|MINUS.
   TODO: It cannot be on the left of a MINUS, because that expression makes no sense.
*/
additiveExpr
	:	lhs=multiplicativeExpr ( ( PLUS | MINUS ) => ((op+=PLUS^|op+=MINUS^) rhs+=multiplicativeExpr))*
	;

multOperator
	:(	value=MULT
	|	value=DIVISION
	|	value=DIV
	|	value=MODULO ) -> $value
	;

multiplicativeExpr
	:	lhs=bitwiseXORExpr (op+=multOperator^ rhs+=bitwiseXORExpr)*
	;

bitwiseXORExpr
	:	lhs=unaryExpr (op+=BITWISE_XOR^ rhs+=unaryExpr)*
	;

unaryExpr
	:	op=MINUS lhs=unaryExpr	-> ^(UNARY_MINUS[$op] $lhs)
	|	op=PLUS lhs=unaryExpr	-> ^(UNARY_PLUS[$op] $lhs)
	|	op=BITWISE_INVERSION lhs=unaryExpr -> ^(BITWISE_INVERSION $lhs)
	|	lhsUnaryNot=unaryNotExpr	-> $lhsUnaryNot
	;
	catch[ NoViableAltException nvae ] 
	{
		if( ( nvae.DecisionNumber == 223 ) && ( Scope.Peek() == "expr" ))
		{		
			nvae = new NoViableAltException( 
				"column_name", 
				nvae.DecisionNumber, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}
	
unaryNotExpr
	:	op=NOT_OP lhs=unaryNotExpr	-> ^(NOT_OP $lhs)
	|	lhsBin=binaryCollateExpr	-> binaryCollateExpr
	;

binaryCollateExpr
	:	( ( BINARY ) => ( op=BINARY lhs=binaryCollateExpr		-> ^(BINARY $lhs) ))
	|	( op=COLLATE lhs=binaryCollateExpr						-> ^(COLLATE $lhs) )
	|	( intervalExpr											-> intervalExpr )
	;
	catch[ NoViableAltException nvae ] 
	{
		if( ( nvae.DecisionNumber == 225 ) && ( Scope.Peek() == "expr" ))
		{		
			nvae = new NoViableAltException( 
				"column_name", 
				nvae.DecisionNumber, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

/* INTERVAL can bind extremely closely, if used as the rightmost subexpr of an expression, otherwise it is in additiveExpr 
   the validating predicate disallows its usage all by itself (can't select just an interval, it must be used in an additive expr)
   defer checking that to a semantic tree phase.
*/
intervalExpr
	:	(INTERVAL ~(LPAREN))=> INTERVAL expr timeUnit /*{input.LA(1) == PLUS || input.LA(1) == MINUS}? */ 
		-> ^(INTERVAL expr timeUnit)
	|	lhsPrim=primary	-> primary
	;
	
primary 
	:	/*lhsParen=parenExpr -> parenExpr */
		CAST LPAREN expr AS cast_data_type RPAREN	-> ^( CAST expr? cast_data_type? )
	|	CONVERT LPAREN expr ( ( COMMA cast_data_type ) | ( USING ( ID | STRING_LEX ) ) ) RPAREN 
													-> ^( CONVERT expr? cast_data_type )
	|	DEFAULT LPAREN ident RPAREN					-> ^( DEFAULT ident )
	|	VALUES LPAREN ident RPAREN					-> ^( VALUES ident )
	|	( lhsLit=literal )	=> literal	-> literal
	|	( subselect )	=> subselect	-> subselect
	|	EXISTS subselect -> ^(EXISTS subselect)
/*	|	functionCall */
/*	|	primary COLLATE ident*/
	|  param_marker -> param_marker
	/*| variable */
	| BINARY primary -> ^( BINARY primary )
	| ident	-> ident
	| LPAREN exprList RPAREN	-> exprList
	| ROW LPAREN exprList RPAREN	-> exprList
	| LCURLY ident expr RCURLY	-> ^( ident expr )
	| match_expr	-> match_expr
	| case_expr		-> case_expr
	;
	catch[ NoViableAltException nvae ] 
	{
		if( ( nvae.DecisionNumber == 229 ) && ( Scope.Peek() == "expr" ))
		{		
			nvae = new NoViableAltException( 
				"column_name", 
				nvae.DecisionNumber, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

param_marker
	: VALUE_PLACEHOLDER ident -> ^( VALUE_PLACEHOLDER ident )
	;

match_expr
	:	MATCH LPAREN column_name_list RPAREN AGAINST LPAREN expr 
	(( IN BOOLEAN MODE ) | ( WITH QUERY EXPANSION ))? RPAREN
	-> ^( MATCH column_name_list expr ( IN BOOLEAN MODE )? ( WITH QUERY EXPANSION )? )
	;

case_expr
	: CASE cond=expr?
		( ( WHEN ( expr ) => whenExpr+=expr THEN thenExpr+=expr )+ 
		( ( ELSE ) => ELSE elseExpr=expr )?
		END
		)
		-> ^( CASE $cond? ^( WHEN $whenExpr $thenExpr ) ( ELSE $elseExpr )? )
	;

case_stmt
	:	CASE 
		(( when_expr+
		// ( WHEN ( expr ) => whenExpr+=expr THEN thenStmt+=statement_list )+ 
		  ( { input.LA(1) == ELSE }? ELSE elseStmt=statement_list )? END CASE) 
		-> ^( CASE_STMT when_expr+ /*^(WHEN $whenExpr* $thenStmt*)* */^( ELSE $elseStmt )? )
	|	( firstPri=primary 
			when_expr+
			( ELSE elseStmt=statement_list )? END CASE )
		-> ^( CASE_STMT $firstPri when_expr+ ^( ELSE $elseStmt )? ))
	;
	catch[ NoViableAltException nvae ] 
	{
		if( nvae.DecisionNumber == 238 )
		{		
			nvae = new NoViableAltException( 
				"column_name", 
				nvae.DecisionNumber, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

when_expr 
  : WHEN whenPri=primary THEN thenStmt=statement_list -> ^( WHEN $whenPri $thenStmt )
  ;

literal
	:	STRING_LEX^
	|	NUMBER^
	|	INT_NUMBER^
	|	( /*{ input.LA( 1 ) == AT1 && input.LA( 2 ) != EOF && input.LA( 2 ) == AT1 && input.LA( 3 ) == GLOBAL }? => **/
		( ( AT1 AT1 ID ) | ( AT1 AT1 GLOBAL ) ) =>
		global_variable^ )
	|	session_variable^
	|	VALUE_PLACEHOLDER^
	|	BINARY_VALUE^
	|	HEXA_VALUE^
	|	NULL^
	|	TRUE^
	|	FALSE^
	|	(functionCall)=>functionCall	
		-> functionCall
	|	field_name^	
	;
// $>

cast_data_type
	:	BINARY (LPAREN INT_NUMBER RPAREN)?	-> ^( BINARY INT_NUMBER? )
	|	CHAR (LPAREN INT_NUMBER RPAREN)? opt_binary	-> ^( CHAR INT_NUMBER? opt_binary? )
	|	NCHAR (LPAREN INT_NUMBER RPAREN)? 	-> ^( CHAR INT_NUMBER? )
	|	DATE^
	|	DATETIME (LPAREN INT_NUMBER RPAREN )?	-> ^( DATETIME INT_NUMBER? )
	|	TIME (LPAREN INT_NUMBER RPAREN )?		-> ^( TIME INT_NUMBER? )
	|	DECIMAL	(LPAREN num1=INT_NUMBER /*COMMA num2=INT_NUMBER RPAREN*/)?
												-> ^( DECIMAL $num1? /* $num2? */ )
	|	SIGNED INTEGER?		-> SIGNED
	|	UNSIGNED INTEGER?	-> UNSIGNED
	;

opt_binary
	:	( ASCII BINARY? )
	|	( UNICODE BINARY? )
	|	( BINARY ( ASCII | UNICODE | charset_def )? )
	|	( BYTE )
	|	/* nothing */
	;
	
timeUnit
	: (	unit=MICROSECOND
	|	unit=SECOND
	|	unit=MINUTE
	|	unit=HOUR
	|	unit=DAY
	|	unit=WEEK
	|	unit=MONTH
	|	unit=QUARTER
	|	unit=YEAR
	|	unit=SECOND_MICROSECOND
	|	unit=MINUTE_MICROSECOND
	|	unit=MINUTE_SECOND
	|	unit=HOUR_MICROSECOND
	|	unit=HOUR_SECOND
	|	unit=HOUR_MINUTE
	|	unit=DAY_MICROSECOND
	|	unit=DAY_SECOND
	|	unit=DAY_MINUTE
	|	unit=DAY_HOUR
	|	unit=YEAR_MONTH ) -> $unit
	;

/* TODO: add the SQL_TSI_ prefix versions */
timestampUnit
	:	FRAC_SECOND^
	|	MICROSECOND^
	|	SECOND^
	|	MINUTE^
	|	HOUR^
	|	DAY^
	|	WEEK^
	|	MONTH^
	|	QUARTER^
	|	YEAR^
	;
	
where_condition
	:	expr	-> expr
	;

// $< Transactions

/* generates bogus warning about RELEASE */
transaction options { backtrack=true; memoize=true; }
	// general trx statements
	:		
	( START TRANSACTION ( (WITH CONSISTENT SNAPSHOT) | transaction_read_write_options )?		-> ^(START SNAPSHOT?) )
	| ( commit	-> commit )
	// NUMBER must be (0 | 1), no grammar checks done at this point, TODO check AUTOCOMMIT vs keywords/identifiers
	|	SET AUTOCOMMIT EQUALS one_or_zero_or_placeholder
	|	SET 
		(	txnScope=GLOBAL 
		|	txnScope=SESSION 
		)?
		TRANSACTION ISOLATION LEVEL
		(	READ UNCOMMITTED			-> ^(ISOLATION UNCOMMITTED $txnScope? )
		|	READ COMMITTED				-> ^(ISOLATION COMMITTED $txnScope? )	
		|	REPEATABLE READ				-> ^(ISOLATION REPEATABLE $txnScope? )
		|	SERIALIZABLE				-> ^(ISOLATION SERIALIZABLE $txnScope? )	
		)
	|	release_savepoint				-> ^( release_savepoint )	
	|	lockTables						-> ^( lockTables )
	| xa								-> ^( xa )
	;

commit
	:	
		/*
		The following natural definition doesn't do the trick, for inputs like "commit no release":
		COMMIT WORK?
			(AND NO? CHAIN)?
			(NO? RELEASE)?					-> ^(COMMIT ^(CHAIN NO?)? ^(RELEASE NO?)?)

		(basically AST rewrite rule doesn't use lookahead of more than one)
		*/
		COMMIT WORK?
		(
			(AND NO? CHAIN) (NO? RELEASE)?				-> ^(COMMIT ^(CHAIN NO?) ^(RELEASE NO?)?)
		|	(NO? RELEASE)								-> ^(COMMIT ^(RELEASE NO?))
		|												-> ^(COMMIT)
		)
	;

rollback options { backtrack = true; }
	:	ROLLBACK WORK?
		(
			((AND NO? CHAIN) (NO? RELEASE)?				-> ^(ROLLBACK ^(CHAIN NO?) ^(RELEASE NO?)?) )
		|	((NO? RELEASE)								-> ^(ROLLBACK ^(RELEASE NO?))				)
		/* savepoint syntax */
		|	( TO 
				savepoint? ident 
				/*|															
				( { input.LT(1).Text.ToLower() != "savepoint" }? ident ) */
			) -> ^(ROLLBACK_POINT ident? savepoint? )
		|	(											-> ^(ROLLBACK)								)
		)
	;

transaction_read_write_options
  : { this.mysqlVersion >= 5.6 }? =>  (( READ WRITE ) | (  READ ONLY ) )
  ;

savepoint_ident options { backtrack = true; }
	:	 { input.LT(1).Text.ToLower() == "savepoint" }? savepoint ident	
			-> ^(SAVEPOINT ident )
	;

savepoint options { backtrack = true; }
	: { input.LT(1).Text.ToLower() == "savepoint" }? ( ID | SAVEPOINT )
	;

// savepoint handling
release_savepoint
	:	( RELEASE savepoint ident				-> ^(SAVEPOINT ident )	 )
	;

xa
	:	XA 
	(
		( ( START | BEGIN ) xid ( JOIN | RESUME ) ) -> 
		^( { new CommonTree( new CommonToken( START, "START" ) ) } xid JOIN? RESUME? )
	|	( END xid ( SUSPEND ( FOR MIGRATE )? )?)	-> ^( END xid ( SUSPEND ( FOR MIGRATE )? )? )
	|	( PREPARE xid )								-> ^( PREPARE xid )
	|	( COMMIT xid ( ONE PHASE )? )				-> ^( COMMIT xid )
	|	( ROLLBACK xid )							-> ^( ROLLBACK xid )
	|	( RECOVER )									-> ^( RECOVER )
	)
	;

xid
	:	( gtrid=STRING_LEX | gtrid=HEX_VALUE | gtrid=BINARY_VALUE ) 
			( COMMA ( bqual=STRING_LEX | bqual=HEX_VALUE | bqual=BINARY_VALUE ) ( COMMA INT_NUMBER )?)?	
		-> ^( XID $gtrid $bqual? INT_NUMBER? )
	;


// $> Transactions

// $< Insert   ( SELECT 

insert 
	:	INSERT (opt=LOW_PRIORITY | opt=DELAYED | opt=HIGH_PRIORITY)?
		IGNORE? INTO?
		table=simple_table_ref_no_alias_existing partition_ref?
		( ( LPAREN ident ) => insert_columns ( select | insert_values )
		| ( select | insert_values )
		|	set_columns
		)
		on_dup_key?
		-> ^(INSERT IGNORE? INTO? $opt? ^(TABLE $table)
			insert_columns?
			set_columns?
			select?
			insert_values?
			on_dup_key?)
	;
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
		/*
		 * This tweak fixes the case when there is a syntax error, and the subtree with the table info 
		 * is not included in the tree result (necessary for intellisense).
		 */
		if( table != null && table.Tree != null )
		{
			object root_1 = (object)adaptor.Nil();
			root_1 = (object)adaptor.BecomeRoot(table.Tree, root_1);
			object root_2 = (object)adaptor.Nil();
			root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(TABLE, "TABLE"), root_2);
			adaptor.AddChild(root_2, root_1);
			adaptor.AddChild(retval.Tree, root_2);
		}
	}

insert_columns
	:	(LPAREN column_name_list RPAREN)?	-> ^(COLUMN_LIST column_name_list?)
	;

insert_values
	:	(VALUE|VALUES) LPAREN val+=insert_default_or_expression (COMMA val+=insert_default_or_expression)* RPAREN 
		( COMMA LPAREN val+=insert_default_or_expression (COMMA val+=insert_default_or_expression)* RPAREN )*
			-> ^(INSERT_VALUES VALUES[] $val+)
	;

insert_default_or_expression
	:	DEFAULT		-> ^( INSERT_DEFAULT_EXPR DEFAULT )
	|	expr		-> ^( INSERT_DEFAULT_EXPR expr )
	;
	
set_columns
	:	SET column_assignment (COMMA column_assignment)*	-> ^(SET column_assignment+)
	;

on_dup_key
	:	ON DUPLICATE KEY UPDATE
		column_assignment (COMMA column_assignment)*	-> ^(DUPLICATE column_assignment+)
	;

column_assignment
	:	field_name EQUALS 
		(	DEFAULT			-> ^(EQUALS field_name DEFAULT)
		|	expr			-> ^(EQUALS field_name expr)
		)
	;
	
column_name_list
	:	field_name (COMMA field_name)*	-> ^(COLUMNS field_name+)
	;
// $> Insert

// $< Update
update
	:	UPDATE LOW_PRIORITY? IGNORE?
		table=table_references			// this must be table_references because the mysql parser allows an alias here, even for single table updates (unlike DELETE)
		{ cntUpdateTables = $table.table_count; }
		set=set_columns
		(WHERE where_condition)?
		/* these options are only valid if we update one table */
		({ cntUpdateTables == 1 }? => 
			order_by?
			(LIMIT INT_NUMBER)?	
		)?
		-> ^(UPDATE LOW_PRIORITY? IGNORE? $table $set ^(WHERE where_condition)? order_by? ^(LIMIT INT_NUMBER)?)
	;


// $> Update

// $< Delete

partition_ref
  : { this.mysqlVersion >= 5.6 }? => PARTITION LPAREN ID ( COMMA ID )* RPAREN
  ;

/* both multi table delete trees are basically identical. The FROM and USING nodes are just in there to differentiate between the syntax used, in order to format it correctly
   the AST drops potential .* suffixes for the table names, as they are simply syntactic sugar.
*/
delete
@init {
multiTableDelete = false;
}
	:	DELETE
		( ( LOW_PRIORITY | QUICK | IGNORE ) => ( opts+=LOW_PRIORITY | opts+=QUICK | opts+=IGNORE ))*
		(	FROM 
			t+=simple_table_ref_no_alias_existing (DOT MULT {multiTableDelete = true;} )? partition_ref?
			(COMMA t+=simple_table_ref_no_alias_existing (DOT MULT)? {multiTableDelete = true;} partition_ref? )*
			(USING tr=table_references {multiTableDelete = true;})?
			(WHERE where_condition)?
			({multiTableDelete == false}?=>
				order_by?
				(LIMIT INT_NUMBER)?
			)?
			-> {multiTableDelete}? ^(DELETE ^(OPTIONS $opts+)? ^(TABLE $t)+ ^(USING $tr) ^(WHERE where_condition)?)
			-> ^(DELETE ^(OPTIONS $opts+)? ^(TABLE $t) ^(WHERE where_condition)? order_by? ^(LIMIT INT_NUMBER)?)
		|	t+=simple_table_ref_no_alias_existing (DOT MULT)? (COMMA t+=simple_table_ref_no_alias_existing (DOT MULT)?)*
			FROM tr=table_references
			(WHERE where_condition)?
			-> ^(DELETE ^(OPTIONS $opts+)? ^(TABLE $t)+ ^(FROM $tr) ^(WHERE where_condition)?)
		)
	;

// $> Delete

// $< Lock tables

lockTables
	:	LOCK TABLES tables+=lock_table_ref (COMMA tables+=lock_table_ref)*	-> ^(LOCK $tables)
	|	UNLOCK TABLES														-> ^(UNLOCK TABLES)
	;

lock_table_ref
	:	simple_table_ref_alias
		(	READ  (LOCAL )?					-> ^(READ simple_table_ref_alias LOCAL?)
		|	(LOW_PRIORITY )? WRITE 			-> ^(WRITE simple_table_ref_alias LOW_PRIORITY?)
		)
	;

// $> Lock tables

// $> DML

// $< DDL

// $< Create Table

create_table
scope 
{
  bool hasCreateDefinition;
  bool hasSelect;
}
@init { 
   $create_table::hasCreateDefinition = false;
   $create_table::hasSelect = false;
       }
	:	CREATE (TEMPORARY )? TABLE
		(IF NOT EXISTS )? 
		tableName=simple_table_ref_no_alias
		(((		
	  | (( LPAREN create+=create_definition (COMMA create+=create_definition)* RPAREN 
	    { $create_table::hasCreateDefinition = true; } )?
	      create_table_options? partition_options?
		  (( IGNORE | REPLACE )? AS? select { $create_table::hasSelect = true; } )? )?
	    ) { $create_table::hasCreateDefinition || $create_table::hasSelect }? )
	  | ( ( LIKE oldtblname=simple_table_ref_no_alias ) | LPAREN LIKE oldtblname=simple_table_ref_no_alias RPAREN )
	  )
		-> ^(CREATE_TABLE
				TEMPORARY?
				EXISTS?
				$tableName
				^( LIKE $oldtblname? )?
				^(DEFINITIONS $create+)?
				select?
				create_table_options?
				^( CREATE_PART_OPTS partition_options? )?
			)
	;

partition_options
  : { this.mysqlVersion >= 5.1 }? => ( PARTITION BY (
      ( LINEAR? typepart=HASH LPAREN partexpr=expr RPAREN )
	| ( LINEAR? typepart=KEY LPAREN partcollist=column_name_list? RPAREN )
	| ( typepart=RANGE (( LPAREN partexpr=expr RPAREN ) | partition_options_columnlist ))
	| ( typepart=LIST (( LPAREN partexpr=expr RPAREN ) | partition_options_columnlist ))
    )
	( PARTITIONS numpartitions=INT_NUMBER )?
	(
	  SUBPARTITION BY
	  (
	     ( LINEAR? typesubpart=HASH LPAREN subpartexpr=expr RPAREN )
	   | ( LINEAR? typesubpart=KEY LPAREN subpartcollist=column_name_list? RPAREN )
	  )
	  ( SUBPARTITIONS numsubpartitions=INT_NUMBER )?
	)?
	( LPAREN partition_definition ( COMMA partition_definition )* RPAREN )? )
	-> ^( PARTITION BY $typepart $partexpr? ^( KEY $partcollist? )? ^( PARTITIONS $numpartitions? )? 
		^( SUBPARTITION ^( $typesubpart $subpartexpr? $subpartcollist? )? $numsubpartitions? )?)
  ;

partition_options_columnlist
  : { this.mysqlVersion >= 5.5 }? => ( COLUMNS LPAREN column_name_list RPAREN )
  ;

partition_definition
  : PARTITION partid=ident
    ( VALUES 
	  (
		( LESS THAN (( (LPAREN ( valuesexpr=expr | partition_definition_values | MAXVALUE ) RPAREN )) | MAXVALUE )) 
	  | ( IN LPAREN exprList RPAREN )
	  )
	)?
	( STORAGE? ENGINE EQUALS? enginename=engine_name )?
	( COMMENT EQUALS? commenttext=STRING_LEX )?
	( DATA DIRECTORY EQUALS? datadir=STRING_LEX )?
	( INDEX DIRECTORY EQUALS? indexdir=STRING_LEX )?
	( MAX_ROWS EQUALS? maxrows=INT_NUMBER )?
	( MIN_ROWS EQUALS? minrows=INT_NUMBER )?
	( TABLESPACE EQUALS? tablespacename=ident )?
	( NODEGROUP EQUALS? nodegroupid=ident )?
	( subpartdef+=subpartition_definition ( COMMA subpartdef+=subpartition_definition )* )?
	-> ^( PARTITION $partid ^( VALUES MAXVALUE? $valuesexpr? ^( IN exprList? )?  )
		^( ENGINE $enginename? )? ^( COMMENT $commenttext? )? ^( DATA $datadir? )? ^( INDEX $indexdir? )?
		^( MAX_ROWS $maxrows? )? ^( MIN_ROWS $minrows? )? ^( TABLESPACE $tablespacename? )?
		^( NODEGROUP $nodegroupid? )? ^( SUBPART_DEF $subpartdef? )?
		 )
  ;

partition_definition_values
  : { this.mysqlVersion >= 5.5 }? => exprList
  ;

subpartition_definition
  : SUBPARTITION logicalname=ident
    ( STORAGE? ENGINE EQUALS? enginename=engine_name )?
	( COMMENT EQUALS? commenttext=STRING_LEX )?
	( DATA DIRECTORY EQUALS? datadir=STRING_LEX )?
	( INDEX DIRECTORY EQUALS? indexdir=STRING_LEX )?
	( MAX_ROWS EQUALS? maxrows=INT_NUMBER )?
	( MIN_ROWS EQUALS? minrows=INT_NUMBER )?
	( TABLESPACE EQUALS? tablespacename=ident )?
	( NODEGROUP EQUALS? nodegroupid=ident )?
	-> ^( SUBPARTITION $logicalname ^( ENGINE $enginename? )?
		^( COMMENT $commenttext? )? ^( DATA $datadir? )? ^( INDEX $indexdir? )? ^( MAX_ROWS $maxrows? )?
		^( MIN_ROWS $minrows? )? ^( TABLESPACE $tablespacename? )? ^( NODEGROUP $nodegroupid? )? )
  ;

create_table_options
  :	create_tbl_opt+=create_table_option ( COMMA? create_tbl_opt+=create_table_option )* // -> create_table_option*
	-> ^( CREATE_TBL_OPTS $create_tbl_opt )
  ;

one_or_zero
 : ( { input.LT( 1 ).Text == "1" || input.LT( 1 ).Text == "0" }? => INT_NUMBER ) -> INT_NUMBER
 ;

one_or_zero_or_placeholder
 : ( { input.LT( 1 ).Text == "1" || input.LT( 1 ).Text == "0" || input.LT( 1 ).Text == "?" }? => number_or_placeholder ) -> number_or_placeholder
 ;
create_table_option
	:	(( ENGINE | create_table_top_type ) EQUALS? engine_name )			-> ^( CREATE_TBL_OPT ENGINE? create_table_top_type? engine_name )
	|	( AUTO_INCREMENT EQUALS? number_or_placeholder )				-> ^( CREATE_TBL_OPT AUTO_INCREMENT number_or_placeholder )
	|	( AVG_ROW_LENGTH EQUALS? INT_NUMBER )				-> ^( CREATE_TBL_OPT AVG_ROW_LENGTH INT_NUMBER )
	|	( DEFAULT? charset_equals )							-> ^( CREATE_TBL_OPT charset_equals )
	|	( CHECKSUM EQUALS? one_or_zero )					-> ^( CREATE_TBL_OPT CHECKSUM one_or_zero )
	|	( DEFAULT? collate_equals )							-> ^( CREATE_TBL_OPT collate_equals )
	|	( COMMENT EQUALS? STRING_LEX )							-> ^( CREATE_TBL_OPT COMMENT STRING_LEX )
	|	( CONNECTION EQUALS? STRING_LEX )						-> ^( CREATE_TBL_OPT CONNECTION STRING_LEX )
	|	( DATA DIRECTORY EQUALS? STRING_LEX )					-> ^( CREATE_TBL_OPT DATA STRING_LEX )
	|	( DELAY_KEY_WRITE EQUALS? one_or_zero )				-> ^( CREATE_TBL_OPT DELAY_KEY_WRITE one_or_zero )
	|	( INDEX DIRECTORY EQUALS? STRING_LEX )					-> ^( CREATE_TBL_OPT INDEX STRING_LEX )
	|	( INSERT_METHOD	EQUALS? ( NO | FIRST | LAST ) )		-> ^( CREATE_TBL_OPT INSERT_METHOD )
	|	( MAX_ROWS EQUALS? INT_NUMBER )						-> ^( CREATE_TBL_OPT MAX_ROWS INT_NUMBER )
	|	( MIN_ROWS EQUALS? INT_NUMBER )						-> ^( CREATE_TBL_OPT MIN_ROWS INT_NUMBER )
	|	( PACK_KEYS EQUALS? ( one_or_zero | DEFAULT ) )		-> ^( CREATE_TBL_OPT PACK_KEYS one_or_zero? DEFAULT? )
	|	( PASSWORD EQUALS? STRING_LEX )							-> ^( CREATE_TBL_OPT PASSWORD STRING_LEX )
	|	( ROW_FORMAT EQUALS? ( DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT ) )
			-> ^( CREATE_TBL_OPT ROW_FORMAT DEFAULT? DYNAMIC? FIXED? COMPRESSED? REDUNDANT? COMPACT? )
	|	( UNION EQUALS? LPAREN tabref+=simple_table_ref_no_alias ( COMMA tabref+=simple_table_ref_no_alias )* RPAREN )
			-> ^( CREATE_TBL_OPT UNION $tabref? )
	/*|	()*/
	;

create_table_top_type
	: { this.mysqlVersion <= 5.0 }? => TYPE
	;

engine_name
	:	ident^ | INNODB^
	;

create_definition
	: { input.LA( 1 ) == CONSTRAINT }? ((CONSTRAINT ident? ) 
			(( PRIMARY KEY index_type? LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_option* )
			|	( FOREIGN KEY ( index_name=ident? ) LPAREN index_col_name 
				( COMMA index_col_name )* RPAREN reference_definition )
			|	( UNIQUE ( INDEX | KEY ) index_name=ident? index_type? 
			  	  LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_option* )))
	| { input.LA( 1 ) == PRIMARY }? ( PRIMARY KEY index_type? LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_option* )
	|	( FOREIGN KEY ( index_name=ident? ) LPAREN index_col_name 
				( COMMA index_col_name )* RPAREN reference_definition )
	|	( UNIQUE ( INDEX | KEY )? index_name=ident? index_type? 
			  	  LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_option* )
	|	( ( INDEX | KEY ) ident? index_type? LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_option* )
	|	( ( FULLTEXT | SPATIAL ) ( INDEX | KEY ) index_name=ident? LPAREN index_col_name ( COMMA index_col_name )* RPAREN
		index_option* )
	|	( CHECK LPAREN expr RPAREN )?
	|	colName=ident column_definition	-> ^(DEFINITION $colName column_definition)
	;
	
// $> Create Table

column_definition
	:	data_type column_attr*	-> ^( TYPE data_type column_attr* )
	;

column_attr
	: autoInc=AUTO_INCREMENT^
	| notSym=NOT^ NULL
	| nullSym=NULL^
	| DEFAULT^ literal
	| UNIQUE^ uniqueKey=KEY?
	| PRIMARY? generalKey=KEY^
	| COMMENT^ STRING_LEX
	// the following two are NDB specific
	| COLUMN_FORMAT^ ( colfmt=FIXED | colfmt=DYNAMIC | colfmt=DEFAULT )
	| STORAGE^ ( storval=DISK | storval=MEMORY | storval=DEFAULT)
	;

data_type
	:	type=BIT 
		( LPAREN number_or_placeholder  RPAREN )?	-> ^( DATA_TYPE $type number_or_placeholder? )
	|	(	type=TINYINT
		|	type=SMALLINT
		|	type=MEDIUMINT
		|	type=INT
		|	type=INTEGER
		|	type=BIGINT
		)
		(LPAREN number_or_placeholder  RPAREN)?
		(SIGNED | UNSIGNED )?
		(ZEROFILL )?					
			-> ^( DATA_TYPE $type number_or_placeholder? SIGNED? UNSIGNED? ZEROFILL? )
	|	(	type=REAL
		|	type=DOUBLE
		|	type=FLOAT
		|	type=DECIMAL
		|	type=NUMERIC
		)
		(LPAREN num1=number_or_placeholder ( COMMA num2=number_or_placeholder )? RPAREN )?
		(SIGNED | UNSIGNED )?
		(ZEROFILL )?
		-> ^( DATA_TYPE $type ^( LPAREN $num1 $num2? )? SIGNED? UNSIGNED? ZEROFILL? )	
	|	DATETIME datetime_precision? -> ^( DATA_TYPE DATETIME datetime_precision?)			
	|	DATE		-> ^( DATA_TYPE DATE )
	|	TIME datetime_precision? -> ^( DATA_TYPE TIME datetime_precision?)
	|	( TIMESTAMP | timestamp )	-> ^( DATA_TYPE TIMESTAMP? timestamp? )	
	|	YEAR		-> ^( DATA_TYPE YEAR )
	|	TINYBLOB	-> ^( DATA_TYPE TINYBLOB )
	|	BLOB		-> ^( DATA_TYPE BLOB )
	|	MEDIUMBLOB	-> ^( DATA_TYPE MEDIUMBLOB )
	|	LONGBLOB	-> ^( DATA_TYPE LONGBLOB )
	|	CHAR		
		( LPAREN INT_NUMBER RPAREN )?
		(charset_def )?
		(collate )?	-> ^( DATA_TYPE CHAR INT_NUMBER? charset_def? collate? )
	|   VARCHAR
		LPAREN number_or_placeholder RPAREN
		(charset_def )?
		(collate )? -> ^( DATA_TYPE VARCHAR number_or_placeholder? charset_def? collate? )
	|	(	type=BINARY
		|	type=VARBINARY
		)
		LPAREN number_or_placeholder RPAREN
					-> ^( DATA_TYPE $type number_or_placeholder? )
	|	(	type=TINYTEXT
		|	type=TEXT	
		|	type=MEDIUMTEXT
		|	type=LONGTEXT
		)
		(BINARY )?
		(charset_def )?
		(collate )? -> ^( DATA_TYPE $type BINARY? charset_def? collate? )
	|	(	type=ENUM
		|	type=SET
		)
		LPAREN values+=STRING_LEX (COMMA values+=STRING_LEX)* RPAREN
		(charset_def )?
		(collate )? -> ^( DATA_TYPE $type ^( LPAREN $values+ ) charset_def? collate? )
	| type=BOOLEAN -> ^(DATA_TYPE $type)
	| type=BOOL -> ^(DATA_TYPE $type)
	;

datetime_precision
:  { this.mysqlVersion >= 5.6 }? => (LPAREN num1=INT_NUMBER RPAREN {(Convert.ToInt32($num1.Text) <= 6 && Convert.ToInt32($num1.Text) >= 1)}?)  -> ^( DATETIME_PRECISION INT_NUMBER? )
;

timestamp
  : { this.mysqlVersion >= 5.1 }? => TIMESTAMP ( LPAREN INT_NUMBER RPAREN )? -> ^( TIMESTAMP INT_NUMBER? )
  ;

charset_def
	:	charset
		(	ident
		|	STRING_LEX 
		|	BINARY
		) -> ^( charset ident? STRING_LEX? BINARY? )
	;

collate
	:	COLLATE 
		(	ident 
		|	STRING_LEX 
		) -> ^( COLLATE ident? STRING_LEX? )
	;

charset_equals
  : charset EQUALS?
	(	ident
	|	STRING_LEX 
	|	BINARY
	) -> ^( charset ident? STRING_LEX? BINARY? )
  ;

charset
  : ( ( CHARACTER SET ) | CHARSET ) -> ^( CHARACTER_SET )
  ;

collate_equals
  : COLLATE EQUALS?
	(	ident
	|	STRING_LEX 
	) -> ^( COLLATE ident? STRING_LEX? )
  ;
	
reference_definition
	:	REFERENCES simple_table_ref_no_alias LPAREN index_col_name ( COMMA index_col_name )* RPAREN
		( MATCH FULL | MATCH PARTIAL | MATCH SIMPLE )?
		( ON DELETE reference_option )?
		( ON UPDATE reference_option )?
	;

reference_option
	:	RESTRICT
	|	CASCADE
	|	SET NULL
	|	NO ACTION
	;

index_col_name
	:	ident	( LPAREN length=INT_NUMBER RPAREN )? ( ASC | DESC )?
	;

index_type
	:	( USING ( BTREE | HASH ) )
	;
// $> DDL

index_option
  : KEY_BLOCK_SIZE EQUALS? INT_NUMBER
  | index_type
  | WITH PARSER ident
  ;

ifnull_expr
	:	IFNULL LPAREN expr COMMA expr RPAREN
	;

nullif_expr
	:	NULLIF LPAREN expr COMMA expr RPAREN
	;


functionCall
	:	  
	  ADDDATE LPAREN date=expr COMMA 
	  (	(INTERVAL)=> INTERVAL interval=expr timeUnit RPAREN		-> ^(FUNC ^(ADDDATE $date $interval timeUnit))
	  |	days=expr RPAREN		-> ^(FUNC ^(ADDDATE $date $days))
	  )
	| AVG LPAREN DISTINCT? ALL? expr RPAREN				-> ^( FUNC ^( AVG expr? ) )
	| BIT_AND LPAREN ALL? expr RPAREN					-> ^( FUNC ^( BIT_AND expr? ))
	| BIT_OR LPAREN ALL? expr RPAREN					-> ^( FUNC ^( BIT_OR expr? ))
	| BIT_XOR LPAREN ALL? expr RPAREN					-> ^( FUNC ^( BIT_XOR expr? ))
	| CHAR LPAREN exprList ( USING ( ID | STRING_LEX ) )? RPAREN
														-> ^( FUNC ^( CHAR exprList? ))
	| COUNT LPAREN DISTINCT? ( MULT | exprList ) RPAREN	-> ^( FUNC ^( COUNT MULT? exprList? ))	
	| DATE_ADD LPAREN date=expr COMMA INTERVAL interval=expr timeUnit RPAREN				-> ^(FUNC ^(DATE_ADD $date $interval timeUnit))
	| DATE_SUB LPAREN date=expr COMMA INTERVAL interval=expr timeUnit RPAREN		-> ^(FUNC ^(DATE_SUB $date $interval timeUnit))
	| EXTRACT LPAREN timeUnit FROM expr RPAREN			-> ^(FUNC ^(EXTRACT timeUnit expr))
	| GET_FORMAT LPAREN 
			(type=DATE | type=TIME | type=DATETIME)
			locale=expr
		RPAREN								-> ^(FUNC ^(GET_FORMAT $type $locale))
	| GROUP_CONCAT LPAREN DISTINCT? exprList order_by? ( SEPARATOR STRING_LEX )? RPAREN 
														-> ^( FUNC ^( GROUP_CONCAT exprList? order_by? ) )
	| MAX LPAREN DISTINCT? ALL? expr RPAREN				-> ^( FUNC ^( MAX expr? ))
	| MIN LPAREN DISTINCT? ALL? expr RPAREN				-> ^( FUNC ^( MIN expr? ))
	| POSITION LPAREN substr=expr IN str=expr RPAREN	-> ^(FUNC ^(POSITION $substr $str))		// todo: LOCATE as well?
	| STD LPAREN ALL? expr RPAREN						-> ^( FUNC ^( STD expr? ))
	| STDDEV_POP LPAREN ALL? expr RPAREN				-> ^( FUNC ^( STDDEV_POP expr? ))
	| STDDEV_SAMP LPAREN ALL? expr RPAREN				-> ^( FUNC ^( STDDEV_SAMP expr? ))
	| SUBDATE LPAREN date=expr COMMA
			(	days=expr			-> ^(FUNC ^(SUBDATE $date $days))
			|	(INTERVAL)=>INTERVAL interval=expr timeUnit	-> ^(FUNC ^(SUBDATE $date $interval timeUnit))
			)
		RPAREN
	// SUBSTR is an alias for SUBSTRING
	| (funcName=SUBSTR | funcName=SUBSTRING) LPAREN 
			str=expr 
			(	COMMA position=expr COMMA len=expr? 				-> ^(FUNC ^($funcName $str $position $len?))
			|	FROM position=expr (FOR len=expr)? 		-> ^(FUNC ^($funcName $str $position $len? FROM?))
			)
			RPAREN
	| SUM LPAREN DISTINCT? ALL? expr RPAREN				-> ^( FUNC ^( SUM expr? ))
	| TIME LPAREN expr RPAREN							-> ^( FUNC ^( TIME expr? ))
	| TIMESTAMP LPAREN e1=expr ( COMMA e2=expr )? RPAREN
														-> ^( FUNC ^( TIMESTAMP $e1 $e2 ))
	| TIMESTAMP_ADD LPAREN
			timestampUnit
			interval=expr
			date=expr
			RPAREN										-> ^(FUNC ^(TIMESTAMP_ADD $date $interval timestampUnit))
	| TIMESTAMP_DIFF LPAREN
			timestampUnit
			date1=expr
			date2=expr
			RPAREN										-> ^(FUNC ^(TIMESTAMP_DIFF $date1 $date2 timestampUnit))
	| TRIM LPAREN
		(
		( e1=expr ( FROM e2=expr )? )					-> ^(FUNC ^(TRIM $e1 $e2?))
	  | (	(pos=BOTH | pos=LEADING | pos=TRAILING)
			remstr=expr? FROM str=expr					-> ^(FUNC ^(TRIM $str $remstr? $pos? ))
		)
		)
		RPAREN
	| VAR_POP LPAREN ALL? expr RPAREN					-> ^( FUNC ^( VAR_POP expr? ) )
	| VAR_SAMP LPAREN ALL? expr RPAREN					-> ^( FUNC ^( VAR_SAMP expr? ))
	| VARIANCE LPAREN ALL? expr RPAREN					-> ^( FUNC ^( VARIANCE expr? ))	
	| ((WEIGHT LPAREN expr 
		(( AS ( CHAR | BINARY ) ws_nweights )? opt_ws_levels ) |
		( COMMA n+=NUMBER COMMA n+=NUMBER COMMA n+=NUMBER )
		RPAREN	)										-> ^( FUNC ^( WEIGHT expr ws_nweights? opt_ws_levels? $n* )) )
	/* functions with optional parenthesis */
	| CURDATE ( LPAREN RPAREN )?						-> ^( FUNC ^( CURDATE ))
	| UTC_DATE ( LPAREN RPAREN )?						-> ^( FUNC ^( UTC_DATE ))
	/* these are only the parenthesis-less constructions, all others are caught at the end of the rule */
	| CURRENT_DATE										-> ^( FUNC ^( CURRENT_DATE ))
	| CURRENT_TIME										-> ^( FUNC ^( CURRENT_TIME ))
	| CURRENT_TIMESTAMP									-> ^( FUNC ^( CURRENT_TIMESTAMP ))
	| LOCALTIME											-> ^( FUNC ^( LOCALTIME ))
	| LOCALTIMESTAMP									-> ^( FUNC ^( LOCALTIMESTAMP ))	
	/* functions that conflict because can also be keywords with a follow up parenthesis somewhere else in the grammar */
	| INSERT LPAREN ins_str=expr COMMA ins_pos=expr COMMA ins_len=expr COMMA ins_newstr=expr RPAREN
														-> ^( FUNC ^( INSERT $ins_str? $ins_pos? $ins_len? $ins_newstr? ))
	| INTERVAL LPAREN exprList RPAREN					-> ^( FUNC ^( INTERVAL exprList ))
	| MINUTE LPAREN expr RPAREN							-> ^( FUNC ^( MINUTE expr ))
	| MONTH LPAREN expr RPAREN							-> ^( FUNC ^( MONTH expr ))
	| OLD_PASSWORD LPAREN expr RPAREN					-> ^( FUNC ^( OLD_PASSWORD expr ))
	| PASSWORD LPAREN expr RPAREN						-> ^( FUNC ^( PASSWORD expr ))	
	| SECOND LPAREN expr RPAREN							-> ^( FUNC ^( SECOND expr ))
	| YEAR LPAREN expr RPAREN							-> ^( FUNC ^( YEAR expr ))
	/* generic functions we don't know */
	| name=ID args=parenOptExprList						-> ^(FUNC ^($name $args))
	| dbname=ID DOT name=ID args=parenOptExprList		-> ^(FUNC ^( $name $args ^( DBNAME $dbname )))
	;

opt_ws_levels
	: ( LEVEL ws_level_list_or_range )?
	;

ws_level_list_or_range
	: ( NUMBER MINUS ) => ws_level_range
	| ws_level_list
	;

ws_level_range
	: ws_level_number MINUS ws_level_number
	;

ws_level_list
	: ws_level_list_item ( COMMA ws_level_list_item )*
	;

ws_level_list_item
	: ws_level_number ws_level_flags
	;

ws_level_number
	: NUMBER
	;

ws_level_flags
	: 
	  ( ws_level_flag_desc ws_level_flag_reverse? )
	| ( ws_level_flag_reverse )
	| /* nothing */
	;

ws_level_flag_reverse
	: REVERSE
	;

ws_level_flag_desc
	: ASC 
	| DESC
	;

ws_nweights
	: LPAREN NUMBER RPAREN
	;

/* TODO: Add ASTs for all drops */
drop_database
	:	DROP database_or_schema ( IF EXISTS )? ident -> ^( DROP ^( DATABASE ident? ))
	;

database_or_schema
	:	DATABASE | SCHEMA
	;

drop_event
	:   { this.mysqlVersion >= 5.1 }? => DROP EVENT ( IF EXISTS )? ident -> ^( DROP ^( EVENT ident? ))
	;

drop_routine
	:	DROP ( functype=PROCEDURE | functype=FUNCTION ) ( IF EXISTS )? simple_table_ref_no_alias
		-> ^( DROP $functype simple_table_ref_no_alias? )
	;

drop_index
	:	DROP ( ONLINE | OFFLINE )? INDEX ident ON simple_table_ref_no_alias
		-> ^( DROP ^( INDEX ident? ON simple_table_ref_no_alias? ))
	;

drop_logfile
	:	DROP LOGILE GROUP ident ENGINE ( EQUALS )? ( NDB | NDBCLUSTER )
		->	^( DROP ^( LOGFILE ident? ))
	; 

drop_server
	:	DROP SERVER ( IF EXISTS )? ident
		->	^( DROP ^( SERVER ident? ) )
	;

drop_table
	:	DROP ( TEMPORARY )? ( TABLE | TABLES ) 
	(
		( IF ) => (( IF EXISTS )	simple_obj_ref_no_alias_existing_list ( cascade_or_restrict )? )
	|	( simple_obj_ref_no_alias_existing_list ( cascade_or_restrict )? ) )
		-> ^( DROP { new CommonTree( new CommonToken( TABLE, "TABLE" ) ) } 
			simple_obj_ref_no_alias_existing_list? )
	;
	catch[ NoViableAltException nvae ] 
	{
		if( nvae.DecisionNumber == 565 )
		{
			nvae = new NoViableAltException( 
				"simple_table_ref_no_alias_existing", 
				nvae.DecisionNumber, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}	

drop_user
	:	DROP user user_specification_list
		-> ^( DROP ^( user user_specification_list? ))
	;

drop_trigger
	:	DROP TRIGGER ( IF EXISTS )? simple_obj_ref_no_alias
		-> ^( DROP ^( TRIGGER simple_obj_ref_no_alias? ))
	;

drop_view
	:	DROP VIEW ( IF EXISTS )? simple_obj_ref_no_alias_list ( cascade_or_restrict )?
		-> ^( DROP ^( VIEW simple_obj_ref_no_alias_list? ))
	;

simple_obj_ref_no_alias_existing_list
	:	simple_table_ref_no_alias_existing ( COMMA simple_table_ref_no_alias_existing )* 
		-> ^( OBJ_LIST simple_table_ref_no_alias_existing* )
	;

simple_obj_ref_no_alias_list
	:	obj_ref+=simple_table_ref_no_alias ( COMMA obj_ref+=simple_table_ref_no_alias )* 
		-> ^( $obj_ref )+
	;

cascade_or_restrict
	: type=RESTRICT | type=CASCADE	-> ^( $type )
	;

rename_database
	:	RENAME ( type=DATABASE | type=SCHEMA ) old_dbname=ident TO new_dbname=ident
		-> ^( RENAME ^( $type $old_dbname $new_dbname ))
	;

rename_table
	:	RENAME TABLE table_src_to_dst_list
		-> ^( RENAME ^( TABLE table_src_to_dst_list ))
	;

rename_user
	:	RENAME user newUsers+=user_specification TO oldUsers+=user_specification 
		( COMMA newUsers+=user_specification TO oldUsers+=user_specification )*
		-> ^( RENAME user $newUsers $oldUsers )
	;

table_src_to_dst_list
	:	old_tblname+=simple_table_ref_no_alias_existing TO new_tblname+=simple_table_ref_no_alias 
		( COMMA old_tblname+=simple_table_ref_no_alias_existing TO new_tblname+=simple_table_ref_no_alias )*
		-> ^( $old_tblname $new_tblname )*
	;

truncate_table
	:	TRUNCATE ( t=TABLE )? simple_table_ref_no_alias_existing
		/* This rewrite rule forces a creation of the "optional" TABLE token in the AST. */
		-> ^( TRUNCATE ^( { new CommonTree( new CommonToken( TABLE, "TABLE" ) ) } 
			simple_table_ref_no_alias_existing? ))
	;

set_password
	:	SET PASSWORD ( FOR user_specification )? EQUALS 
	(
		( PASSWORD LPAREN STRING_LEX RPAREN )
	|	( OLD_PASSWORD LPAREN STRING_LEX RPAREN )
	|	( STRING_LEX )
	)	-> ^( SET_PASSWORD user_specification? PASSWORD? OLD_PASSWORD? STRING_LEX )
	;

grant
	: ( GRANT PROXY ) => ( grant_proxy -> ^( GRANT grant_proxy ) )
	|
		( GRANT priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? 
			( COMMA priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? )*
			ON ( object_type )? privilege_level
			TO user_specification_list
			( REQUIRE ( NONE | ( sslopt+=ssl_option ( AND sslopt+=ssl_option )* )) )?
			( WITH withopt+=with_option ( withopt+=with_option )* )?
		->	^( GRANT $priv $collist? ^( ON object_type? privilege_level )
				^( TO user_specification_list ) ^( REQUIRE NONE? $sslopt? )? ^( WITH $withopt? )? ) )
	;

grant_proxy
  :  { this.mysqlVersion >= 5.5 }? => GRANT PROXY ON user_specification TO user_specification_list ( WITH GRANT OPTION )?
	-> ^( PROXY user_specification? user_specification_list? )
  ;

ssl_option
	:	
	(
		sslopt=SSL
	|	sslopt=X509
	|	sslopt=CIPHER STRING_LEX
	|	sslopt=ISSUER STRING_LEX
	|	sslopt=SUBJECT STRING_LEX
	)	-> ^( SSL_OPTION $sslopt STRING_LEX? )
	;

with_option
	:	
	(
		withopt=GRANT OPTION
	|	withopt=MAX_QUERIES_PER_HOUR INT_NUMBER
	|	withopt=MAX_UPDATES_PER_HOUR INT_NUMBER
	|	withopt=MAX_CONNECTIONS_PER_HOUR INT_NUMBER
	|	withopt=MAX_USER_CONNETIONS INT_NUMBER
	)	->	^( WITH_OPTION $withopt INT_NUMBER? )
	;

revoke_user
	:
	  ( REVOKE PROXY ) => ( revoke_proxy -> ^( REVOKE revoke_proxy ) )
	| (
		REVOKE 		
		(
		( ALL ) =>
		(
			 ALL PRIVILEGES COMMA GRANT OPTION FROM user_specification_list
		)	->	^( REVOKE ALL user_specification_list )
		|
		(
			priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? 
			( COMMA priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? )*
			ON ( object_type )? privilege_level
			FROM user_specification_list
		)	->	^( REVOKE $priv $collist? ^( ON object_type? privilege_level ) ^( FROM user_specification_list ))
		)
	)
	;

revoke_proxy
  : { this.mysqlVersion >= 5.5 }? => REVOKE PROXY ON user_specification FROM user_specification_list
	-> ^( PROXY user_specification? user_specification_list? )
  ;

object_type
	:	
	( typeobj=TABLE
	| typeobj=FUNCTION
	| typeobj=PROCEDURE
	)	-> ^( OBJECT_TYPE $typeobj )
	;

privilege_level
	:	
	(
		first=MULT
	  | first=MULT DOT second=MULT
	  | first=ID DOT second=MULT
	  | first=ID DOT second=ID
	  | first=ID
	)	-> ^( PRIVILEGE_LEVEL $first $second? )
	;

privilege_type
	:	
		ALL^ ( PRIVILEGES )?
	|	ALTER^
	|	ALTER^ ROUTINE
	|	CREATE^
	|	CREATE^ ROUTINE
	|	CREATE^ TEMPORARY TABLES
	|	CREATE^ user
	|	CREATE^ VIEW
	|	DELETE^
	|	DROP^
	|	EVENT^
	|	EXECUTE^
	|	FILE^
	|	GRANT^ OPTION
	|	INDEX^
	|	INSERT^
	|	LOCK^ TABLES
	|	PROCESS^
	|	REFERENCES^
	|	RELOAD^
	|	REPLICATION^ CLIENT
	|	REPLICATION^ SLAVE
	|	SELECT^
	|	SHOW^ DATABASES
	|	SHOW^ VIEW
	|	SHUTDOWN^
	|	SUPER^
	|	TRIGGER^
	|	UPDATE^
	|	USAGE^
	/*|	CREATE TABLESPACE*/
	;

/* Special treatment for user keyword due to conflict with checkFunctionAsID function */
user
	:	USER -> USER //{ input.LT( 1 ).Text.ToUpper() == "USER" }? => ID	-> ID
	;

create_user
	:	CREATE user user_specification_list
		-> ^( CREATE ^( user user_specification_list ))
	;

user_specification_list
	:	user_specification ( COMMA user_specification )*
		-> ^( user_specification )*
	;

user_specification
	:	user_host_or_id_or_string ( IDENTIFIED BY ( PASSWORD )? STRING_LEX )?
		-> ^( user_host_or_id_or_string ( PASSWORD? STRING_LEX )? )
	;

user_host
	: AT1 (ID | STRING_LEX)	-> ^( USER_HOST ID? STRING_LEX? )
	;

user_host_or_id_or_string
	:	ID ( user_host )?		-> ^( USER_HOST_OR_ID_OR_STRING ID user_host? )
		| STRING_LEX ( user_host )?	-> ^( USER_HOST_OR_ID_OR_STRING STRING_LEX user_host? )
	;

sp_call options { backtrack=true; memoize=true; }
	:	CALL ident	-> ^( CALL ident )
	|	CALL ident LPAREN RPAREN	-> ^( CALL ident )
	|	CALL ident LPAREN exprList RPAREN	-> ^( CALL ident exprList )
	;
	catch[ NoViableAltException nvae ] 
	{
		if( nvae.DecisionNumber == 608 )
		{
			nvae = new NoViableAltException( 
					"proc_name", 
					nvae.DecisionNumber, 
					0 /* re.StateNumber*/, 
					nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

create_event 
  :	{ this.mysqlVersion >= 5.1 }? => ( CREATE ( DEFINER EQUALS ( user_specification | CURRENT_USER ))? 
	EVENT
	( IF NOT EXISTS )?
	eventname=simple_obj_ref_no_alias
	ON SCHEDULE schedule
	( ON COMPLETION NOT? PRESERVE )?
	( ENABLE | DISABLE | ( DISABLE ON SLAVE ) )?
	( COMMENT STRING_LEX )?
	DO statement )
	-> ^( CREATE EVENT ^( DEFINER user_specification? )? $eventname? ^( ON_SCHEDULE schedule? )? ^( ON_COMPLETION NOT? PRESERVE )?
		^( ENABLING ENABLE? DISABLE? SLAVE? )? ^( COMMENT STRING_LEX? )? statement? )
  ;

schedule
  : AT mytimestamp=expr ( PLUS intervals+=intervalExpr )*	-> ^( AT $mytimestamp $intervals? )
  |	EVERY everyExpr=expr timeUnit
  	( STARTS timestampStarts=expr ( PLUS intervalsStarts+=intervalExpr )* )?
	( ENDS timestampEnds=expr ( PLUS intervalsEnds+=intervalExpr )* )?
	-> ^( EVERY $everyExpr timeUnit ^( STARTS $timestampStarts $intervalsStarts? )? 
		^( ENDS $timestampEnds $intervalsEnds? )? )
  ;

alter_database
  :	ALTER ( name=DATABASE | name=SCHEMA ) ident 
	(( alter_database_specification* -> ^(ALTER $name ident? alter_database_specification*) ) |
	 ( UPGRADE DATA DIRECTORY NAME -> ^(ALTER $name ident? UPGRADE? ) ) )
  ;

alter_database_specification
  : ( ( DEFAULT )? charset_equals ) -> ^( charset_equals )
  | ( ( DEFAULT )? collate_equals ) -> ^( collate_equals )
  ;

alter_event
  :	{ this.mysqlVersion >= 5.1 }? => ALTER ( DEFINER EQUALS ( user_specification | CURRENT_USER ))? 
	EVENT eventname=simple_obj_ref_no_alias
	( ON SCHEDULE schedule )?
	( ON COMPLETION NOT? PRESERVE )?
	( RENAME TO neweventname=simple_obj_ref_no_alias )?
	( ENABLE | DISABLE | ( DISABLE ON SLAVE ) )?
	( COMMENT STRING_LEX )?
	( DO statement )?
	-> ^( ALTER EVENT ^( DEFINER user_specification? )? $eventname? ^( ON_SCHEDULE schedule? )?
	    ^( ON_COMPLETION NOT? PRESERVE )?
		^( RENAME $neweventname )? ^( ENABLING ENABLE? DISABLE? SLAVE? )? ^( COMMENT STRING_LEX? )? 
		statement? )
  ;

declare_condition options { backtrack=true; memoize=true; }
  : DECLARE ident CONDITION FOR ( INT_NUMBER | SQLSTATE VALUE? STRING_LEX )
	-> ^( DECLARE CONDITION ident INT_NUMBER? STRING_LEX? )
  ;

declare_handler options { backtrack=true; memoize=true; }
  : DECLARE ( type=CONTINUE | type=EXIT | type=UNDO ) 
	HANDLER FOR conds+=condition_value ( COMMA conds+=condition_value )*
	statement
	-> ^( DECLARE_HANDLER $type? ^( HANDLER $conds? )? statement? )
  ;

condition_value
  : INT_NUMBER
  |	SQLSTATE VALUE? STRING_LEX
  | ident
  | SQLWARNING
  | ( NOT FOUND )
  | SQLEXCEPTION
  ;

create_logfile
  : CREATE LOGFILE GROUP logfilename=ident
	ADD UNDOFILE undofile=STRING_LEX
	( INITIAL_SIZE EQUALS? initial_size=size )?
	( UNDO_BUFFER_SIZE EQUALS? undo_buffer_size=INT_NUMBER )?
	( REDO_BUFFER_SIZE EQUALS? redo_buffer_size=INT_NUMBER )?
	( NODEGROUP EQUALS? nodegroupid=ident )?
	( WAIT )?
	( COMMENT EQUALS? commenttext=STRING_LEX )?
	ENGINE EQUALS? enginename=engine_name
	-> ^( CREATE LOGFILE $logfilename? ^( UNDOFILE $undofile? )? ^( INITIAL_SIZE $initial_size? )?
		^( UNDO_BUFFER_SIZE $undo_buffer_size? )? ^( REDO_BUFFER_SIZE $redo_buffer_size? )? 
		^( NODEGROUP $nodegroupid? )? WAIT? ^( COMMENT $commenttext? )? ^( ENGINE $enginename? )?)
  ;

alter_logfile
  : ALTER LOGFILE GROUP logfilename=ident
	ADD UNDOFILE undofile=STRING_LEX
	( INITIAL_SIZE EQUALS? size )?
	( WAIT )?
	( ENGINE EQUALS? enginename=engine_name )?
	-> ^( ALTER LOGFILE $logfilename? ^( UNDOFILE $undofile? )? WAIT? ^( ENGINE $enginename? )?)
  ;

size
  : INT_NUMBER | SIZE
  ;

create_server
  : CREATE SERVER servername=ident
	FOREIGN DATA WRAPPER wrappername=ident
	OPTIONS LPAREN opts+=create_server_option ( COMMA opts+=create_server_option )* RPAREN
	-> ^( CREATE SERVER $servername ^( FOREIGNKEY_DATA_WRAPPER $wrappername )? ^( CREATE_SERVER_OPTIONS $opts? )? )
  ;

alter_server
  : ALTER SERVER servername=ident                                                                                                                       
    OPTIONS LPAREN opts+=create_server_option ( COMMA opts+=create_server_option )* RPAREN
	-> ^( ALTER SERVER $servername ^( CREATE_SERVER_OPTIONS $opts? )? )
  ;

create_server_option
  : ( HOST STRING_LEX )			-> ^( CREATE_SERVER_OPTION HOST STRING_LEX )
  | ( DATABASE STRING_LEX )	-> ^( CREATE_SERVER_OPTION DATABASE STRING_LEX )
  | ( USER STRING_LEX )		-> ^( CREATE_SERVER_OPTION USER STRING_LEX )
  | ( PASSWORD STRING_LEX )	-> ^( CREATE_SERVER_OPTION PASSWORD STRING_LEX )
  | ( SOCKET STRING_LEX )		-> ^( CREATE_SERVER_OPTION SOCKET STRING_LEX )
  | ( OWNER STRING_LEX )		-> ^( CREATE_SERVER_OPTION OWNER STRING_LEX )
  | ( PORT INT_NUMBER )	-> ^( CREATE_SERVER_OPTION PORT INT_NUMBER )
  ;

create_tablespace
  : CREATE TABLESPACE tablespacename=ident
	ADD DATAFILE datafile=STRING_LEX
	USE LOGFILE GROUP logfilegroup=ident
	( EXTENT_SIZE EQUALS? extsize=INT_NUMBER )?
	( INITIAL_SIZE EQUALS? initsize=INT_NUMBER )?
	( AUTOEXTEND_SIZE EQUALS? autosize=INT_NUMBER )?
	( MAX_SIZE EQUALS? maxsize=INT_NUMBER )?
	( NODEGROUP EQUALS? nodegroupid=ident )?
	( WAIT )?
	( COMMENT EQUALS? commenttext=STRING_LEX )?
	ENGINE EQUALS? enginename=engine_name
	-> ^( CREATE TABLESPACE $tablespacename ^( CT_DATAFILE $datafile? )? ^( CT_LOGFILE $logfilegroup )? 
		^( CT_EXTENT_SIZE $extsize? )? ^( CT_INITIAL_SIZE $initsize? )? ^( CT_AUTOEXTEND_SIZE $autosize? )? 
		^( CT_MAX_SIZE $maxsize )? ^( CT_NODEGROUP $nodegroupid? )? WAIT? ^( CT_COMMENT $enginename? )? )
  ;

alter_function
  : ALTER FUNCTION simple_obj_ref_no_alias routine_characteristic*
	-> ^( ALTER FUNCTION simple_obj_ref_no_alias? routine_characteristic* )
  ;

alter_procedure
  : ALTER PROCEDURE simple_obj_ref_no_alias routine_characteristic*
  -> ^( ALTER PROCEDURE simple_obj_ref_no_alias? routine_characteristic* )
  ;

alter_table /*options { backtrack=true; memoize=true; }*/
  : ALTER ( alter_table_online_options )? IGNORE? TABLE tblname=simple_obj_ref_no_alias
    ( alter_specification_table ( COMMA alter_specification_table )* )?
	partition_options?
  ;

alter_table_online_options
  : { this.mysqlVersion <= 5.5 }? => ( ONLINE | OFFLINE )
  ;

alter_specification_table options { backtrack=true; memoize=true; }
  : create_table_option
  | ( ADD COLUMN? colname=ident ) => 
		( ADD COLUMN? colname=ident column_definition (( FIRST | AFTER ) colnameafter=ident )? )
  | ( ADD COLUMN? LPAREN ) => 
		( ADD COLUMN? LPAREN colnamelist+=ident coldef+=column_definition 
		( COMMA colnamelist+=ident coldef+=column_definition )* RPAREN )
  | ( ADD ( INDEX | KEY ) ) => 
		( ADD ( INDEX | KEY ) indexname=ident? index_type? 
		LPAREN indexcolname+=index_col_name ( COMMA indexcolname+=index_col_name )* RPAREN index_option* )
  | ( ADD CONSTRAINT? symbol=ident? PRIMARY ) => 
		( ADD CONSTRAINT? symbol=ident? PRIMARY KEY index_type? 
		LPAREN indexcolname+=index_col_name ( COMMA indexcolname+=index_col_name )* RPAREN index_option* )
  | ( ADD CONSTRAINT? symbol=ident? UNIQUE ) => 
		( ADD CONSTRAINT? symbol=ident? UNIQUE ( INDEX | KEY )? index_type 
		LPAREN indexcolname+=index_col_name ( COMMA indexcolname+=index_col_name )* RPAREN index_option* )
  | ( ADD FULLTEXT ( INDEX | KEY )? indexname=ident 
		LPAREN indexcolname+=index_col_name ( COMMA indexcolname+=index_col_name )* RPAREN index_option* )
  | ( ADD SPATIAL ( INDEX | KEY )? indexname=ident 
      LPAREN indexcolname+=index_col_name ( COMMA indexcolname+=index_col_name )* RPAREN index_option* )
  | ( ADD ( CONSTRAINT symbol=ident? )? FOREIGN KEY indexname=ident? 
	  LPAREN indexcolname+=index_col_name ( COMMA indexcolname+=index_col_name )* RPAREN reference_definition )
  | ( ALTER COLUMN? colname=ident ( ( SET DEFAULT literal ) | ( DROP DEFAULT ) ) )
  | ( CHANGE COLUMN? oldcolname=ident newcolname=ident column_definition (( FIRST | AFTER ) aftercolname=ident )? )
  | ( MODIFY COLUMN? colname=ident column_definition (( FIRST | AFTER ) aftercolname=ident )? )
  | ( DROP COLUMN? colname=ident )
  | ( DROP PRIMARY KEY )
  | ( DROP ( INDEX | KEY ) indexname=ident )
  | ( DROP FOREIGN KEY fksymbol=ident )
  | ( DISABLE KEYS )
  | ( ENABLE KEYS )
  | ( RENAME TO? newtablename=ident )
  | { this.mysqlVersion >= 5.7 }? => ( RENAME ( type=INDEX | type=KEY ) old_index_name=ident TO new_index_name=ident
		                               -> ^( RENAME ^( $type $old_index_name $new_index_name )))
  | ( ORDER BY ordercolname+=ident (( COMMA ) => (COMMA ordercolname+=ident ))* )
  | ( CONVERT TO charset_def collate? )
  | ( DEFAULT? charset_equals collate_equals? )
  | ( DISCARD TABLESPACE )
  | ( IMPORT TABLESPACE )
  | ( ADD PARTITION LPAREN partition_definition RPAREN )
  | ( DROP PARTITION partition_names )
  | ( COALESCE PARTITION INT_NUMBER )
  | ( REORGANIZE PARTITION ( partition_names INTO LPAREN partition_definition RPAREN )? )
  | ( ANALYZE PARTITION ( partition_names | ALL ) )
  | ( CHECK PARTITION ( partition_names | ALL ) )
  | ( OPTIMIZE PARTITION ( partition_names | ALL ) )
  | ( REBUILD PARTITION ( partition_names | ALL ) )
  | ( REPAIR PARTITION ( partition_names | ALL ) )
  | ( PARTITION BY partitioningexpr=expr )
  | ( REMOVE PARTITIONING )
  | truncate_partition
  | alter_specification_table56
  ;

alter_specification_table56
  : { this.mysqlVersion >= 5.6 }? => (
  ALGORITHM EQUALS ( DEFAULT | INPLACE | COPY )
  | LOCK EQUALS ( DEFAULT | NONE | SHARED | EXCLUSIVE )
  | EXCHANGE PARTITION ident WITH TABLE simple_table_ref_no_alias )
  ;

truncate_partition
  : { this.mysqlVersion >= 5.5 }? => TRUNCATE PARTITION LPAREN ( partition_names | ALL ) RPAREN
  ;

partition_names
  : partitionname+=ident ( ( COMMA ident ) => ( COMMA partitionname+=ident ))*
  ;

alter_tablespace
  : ALTER TABLESPACE tablespacename=ident
    ( ADD | DROP ) DATAFILE STRING_LEX
	( INITIAL_SIZE EQUALS? INT_NUMBER )?
	( WAIT )?
	( ENGINE EQUALS? enginename=engine_name )?
  ;

alter_view
  : ALTER 
    ( ALGORITHM EQUALS ( UNDEFINED | MERGE | TEMPTABLE ) )?
	( DEFINER EQUALS ( user_specification | CURRENT_USER ))?
	( SQL SECURITY ( DEFINER | INVOKER ) )?
    VIEW viewname=ident ( LPAREN colname=ident ( COMMA colname=ident )* RPAREN )?
	AS select
	( WITH ( CASCADE | LOCAL ) CHECK OPTION )?
  ;
////////////////
create_index
  : CREATE ( ONLINE | OFFLINE )? ( UNIQUE | FULLTEXT | SPATIAL )? INDEX indexname=simple_obj_ref_no_alias
    index_type?
	ON tblname=simple_obj_ref_no_alias 
	LPAREN indexcols+=index_col_name ( COMMA indexcols+=index_col_name )* RPAREN 
	index_option*
  ;

create_trigger
  : CREATE 
    ( DEFINER EQUALS ( user_specification | CURRENT_USER ))?
    TRIGGER triggername=simple_obj_ref_no_alias ( triggertime=BEFORE | triggertime=AFTER )
	 ( triggerevent=INSERT | triggerevent=UPDATE | triggerevent=DELETE )
	ON tblname=simple_obj_ref_no_alias FOR EACH ROW 
	statement
	-> ^( CREATE TRIGGER ( DEFINER user_specification? CURRENT_USER? )? 
			$triggername? ^( TRIGGERTIME $triggertime? )? $triggerevent? ^( ON $tblname )? statement )
  ;

create_view
  : CREATE
    ( OR REPLACE )?
	( ALGORITHM EQUALS ( UNDEFINED | MERGE | TEMPTABLE ) )?
	( DEFINER EQUALS ( user_specification | CURRENT_USER ))?
	( SQL SECURITY ( DEFINER | INVOKER ) )?
	VIEW viewname=simple_obj_ref_no_alias ( LPAREN column_name_list  RPAREN )?
	AS select
	( WITH ( CASCADED | LOCAL ) CHECK OPTION )? ->
	^( CREATE VIEW $viewname? column_name_list? select? )
  ;

handler 
  : //*
  HANDLER tblname=simple_obj_ref_no_alias
  (
	( OPEN ( 
		(( AS ) => ( AS alias=ident )) 
	  | ( { input.LA( 1 ) != AS }? => alias=ident ) )? 
	)
  | ( READ 
      ( 
		(( FIRST | NEXT ) => ( ( FIRST | NEXT ) ( WHERE expr )? limit? ) )
	  | ( indexname=simple_obj_ref_no_alias 
		(
		( EQUALS | LESS_THAN_EQUAL | GREATER_THAN_EQUAL | LESS_THAN | GREATER_THAN ) => 
	      ( ( ( EQUALS | LESS_THAN_EQUAL | GREATER_THAN_EQUAL | LESS_THAN | GREATER_THAN ) 
			LPAREN exprList RPAREN ( WHERE expr )? limit? ))
		| ( FIRST | NEXT | PREV | LAST ) => ( ( FIRST | NEXT | PREV | LAST ) ( WHERE expr )? limit? )
		) )
	  )
	)
  | ( CLOSE )
  )
  ;//*/
  /*
  : ( HANDLER tblname=simple_obj_ref_no_alias OPEN ( AS? alias=ident )? )
  | ( HANDLER tblname=simple_obj_ref_no_alias READ indexname=simple_obj_ref_no_alias
    ( EQUALS | NOT ) LPAREN exprList RPAREN 
	( WHERE expr )? limit? )
  | ( HANDLER tblname=simple_obj_ref_no_alias READ indexname=simple_obj_ref_no_alias
    ( FIRST | NEXT | PREV | LAST )
	( WHERE expr )? limit? )
  | ( HANDLER tblname=simple_obj_ref_no_alias READ ( FIRST | NEXT )
    ( WHERE expr )? limit? )
  | ( HANDLER tblname=simple_obj_ref_no_alias CLOSE )
  ; //*/
  /*
handler_read_with_index
	: indexname=simple_obj_ref_no_alias 
		(
		( EQUALS | LESS_THAN_EQUAL | GREATER_THAN_EQUAL | LESS_THAN | GREATER_THAN ) => 
	      ( ( ( EQUALS | LESS_THAN_EQUAL | GREATER_THAN_EQUAL | LESS_THAN | GREATER_THAN ) 
			LPAREN exprList RPAREN ( WHERE expr )? limit? ))
		| ( FIRST | NEXT | PREV | LAST ) => ( ( FIRST | NEXT | PREV | LAST ) ( WHERE expr )? limit? )
		)
	;*/

load_data_infile
  : LOAD DATA ( ( LOW PRIORITY ) | ( CONCURRENT ) )? LOCAL? INFILE infile=STRING_LEX
    ( REPLACE | IGNORE )?
	INTO TABLE tblname=simple_obj_ref_no_alias
	partition_ref?
	charset_def?
	( ( FIELDS | COLUMNS )
	  ( TERMINATED BY terminatedbystr=STRING_LEX )?
	  ( OPTIONALLY? ENCLOSED BY enclosedbystr=STRING_LEX )?
	  ( ESCAPED BY escapedbystr=STRING_LEX )?
	)?
	((
		LINES
		( STARTING BY linesstartingbystr=STRING_LEX )
		( TERMINATED BY linesterminatedbystr=STRING_LEX)? 
	)	 
	|
	 ( LINES
	 ( TERMINATED BY linesterminatedbystr=STRING_LEX)
		 ( STARTING BY linesstartingbystr=STRING_LEX )?
	 )
	)?
	( IGNORE INT_NUMBER LINES )?
	( LPAREN exprList RPAREN )?
	( SET setcolname+=ident EQUALS setexpr+=expr ( COMMA setcolname+=ident EQUALS setexpr+=expr )* )?
	-> ^( LOAD DATA $infile? $tblname? )
  ;

replace
scope 
{
  bool replaceV1;
}
@init { $replace::replaceV1 = false; }
  : REPLACE ( LOW_PRIORITY | DELAYED )?
    INTO? tblname=simple_table_ref_no_alias partition_ref?
		( LPAREN colname+=ident ( COMMA colname+=ident )* RPAREN 
		  { $replace::replaceV1 = true; })?
	(( ( ( VALUES | VALUE ) LPAREN ( repexpr+=expr | DEFAULT ) 
	( COMMA ( repexpr+=expr | DEFAULT ) )* RPAREN ) | select )
	{ $replace::replaceV1 = true; })?
	replace_set
	->	^( REPLACE $tblname? $colname* $repexpr* select? replace_set? ) 
  ;

replace_set
  : { $replace::replaceV1 == false }? =>
    ( SET colname+=ident EQUALS ( repsetexpr+=expr | DEFAULT ) ( COMMA colname+=ident EQUALS ( repsetexpr+=expr | DEFAULT ) )* )
	|
	-> ^( REPLACE_SET $colname* $repsetexpr* )
  ;

purge
  : PURGE ( BINARY | MASTER ) LOGS
    (( TO logname=STRING_LEX ) | ( BEFORE datetime=expr ))
  ;

reset_master
  : RESET MASTER
  ;

change_master
  : CHANGE MASTER TO change_master_option ( COMMA change_master_option )*
  ;

change_master_option
  : ( MASTER_BIND EQUALS cm_interfacename=STRING_LEX )
  | ( MASTER_HOST EQUALS cm_hostname=STRING_LEX )
  | ( MASTER_USER EQUALS cm_username=STRING_LEX )
  | ( MASTER_PASSWORD EQUALS cm_password=STRING_LEX )
  | ( MASTER_PORT EQUALS cm_portnum=INT_NUMBER )
  | ( MASTER_CONNECT_RETRY EQUALS cm_interval=INT_NUMBER )
  | ( MASTER_HEARTBEAT_PERIOD EQUALS cm_interval=INT_NUMBER )
  | ( MASTER_LOG_FILE EQUALS cm_masterlogfile=STRING_LEX )
  | ( MASTER_LOG_POS EQUALS cm_masterlogpos=INT_NUMBER )
  | ( RELAY_LOG_FILE EQUALS cm_relayfile=STRING_LEX )
  | ( RELAY_LOG_POS EQUALS cm_relaypos=INT_NUMBER )
  | ( MASTER_SSL EQUALS cm_masterssl=one_or_zero )
  | ( MASTER_SSL_CA EQUALS cm_cafilename=STRING_LEX )
  | ( MASTER_SSL_CAPATH EQUALS cm_capath=STRING_LEX )
  | ( MASTER_SSL_CERT EQUALS cm_cert=STRING_LEX )
  | ( MASTER_SSL_KEY EQUALS cm_key=STRING_LEX )
  | ( MASTER_SSL_CIPHER EQUALS cm_cipher=STRING_LEX )
  | ( MASTER_SSL_VERIFY_SERVER_CERT EQUALS cm_ssl_verify=one_or_zero )
  | ( IGNORE_SERVER_IDS EQUALS LPAREN server_id_list RPAREN )
  ;

server_id_list
  : ( serverid+=INT_NUMBER ( COMMA serverid+=INT_NUMBER )* )?
  ;

/* this is due to deprecation in later version, but still available in 5.1 */
load_data_from_master
  : { this.mysqlVersion < 5.5 }? => LOAD DATA FROM MASTER
  ;

/* this is due to deprecation in later version, but still available in 5.1 */
load_table_from_master
  : { this.mysqlVersion < 5.5 }? => LOAD TABLE tbl_name=simple_obj_ref_no_alias FROM MASTER
  ;

reset_slave
  : RESET SLAVE
  ;

start_slave options { backtrack=true; memoize=true; }
  : START SLAVE ( ( thread_type ) ( COMMA ( thread_type ) )*  )?
  | ( START SLAVE SQL_THREAD? UNTIL
      MASTER_LOG_FILE EQUALS logname=STRING_LEX COMMA MASTER_LOG_POS EQUALS logpos=INT_NUMBER )
  | ( START SLAVE SQL_THREAD? UNTIL RELAY_LOG_FILE EQUALS 
      logname=STRING_LEX COMMA RELAY_LOG_POS logpos=INT_NUMBER )
  ;

thread_type
  : IO_THREAD | SQL_THREAD
  ;

stop_slave
  : STOP SLAVE ( thread_type ( COMMA thread_type )* )?
  ;

analyze_table
  : ANALYZE ( NO_WRITE_TO_BINLOG | LOCAL )? TABLE simple_obj_ref_no_alias_list
  ;

backup_table
  : { this.mysqlVersion < 5.5 }? => BACKUP TABLE simple_obj_ref_no_alias_list TO STRING_LEX
  ;

restore_table
  : { this.mysqlVersion < 5.5 }? => RESTORE TABLE simple_obj_ref_no_alias_list FROM STRING_LEX
  ;

check_table
  : CHECK TABLE simple_obj_ref_no_alias_list check_table_option*
  ;

check_table_option
  : ( FOR UPGRADE ) | QUICK | FAST | MEDIUM | EXTENDED | CHANGED
  ;

checksum_table
  : CHECKSUM TABLE simple_obj_ref_no_alias_list ( QUICK | EXTENDED )
  ;

optimize_table
  : OPTIMIZE ( NO_WRITE_TO_BINLOG | LOCAL )? TABLE simple_obj_ref_no_alias_list
  ;

binlog
  : BINLOG STRING_LEX
  ;

cacheindex
  : CACHE INDEX tblindexlist ( COMMA tblindexlist )* cache_index_partition? IN keycachename=ident
  ;

cache_index_partition
  : { this.mysqlVersion >= 5.5 }? => PARTITION LPAREN ( partition_names | ALL ) RPAREN
  ;

tblindexlist
  : tblname=simple_obj_ref_no_alias 
    ( ( INDEX | KEY ) LPAREN indexname+=simple_obj_ref_no_alias 
	  ( COMMA indexname+=simple_obj_ref_no_alias )* RPAREN )?
  ;
  
flush
  : FLUSH ( NO_WRITE_TO_BINLOG | LOCAL )? flush_option ( COMMA flush_option )*
  ;

flush_option
  : DES_KEY_FILE | HOSTS | LOGS | MASTER | PRIVILEGES | QUERY CACHE | SLAVE | STATUS | 
    TABLES
  ;

kill
  : KILL ( CONNECTION | QUERY ) threadid=INT_NUMBER
  ;

load_index_into_cache
  : LOAD INDEX INTO CACHE  loadtblindexlist ( COMMA loadtblindexlist )*
  ;

loadtblindexlist
  : tblname=simple_obj_ref_no_alias 
    cache_index_partition?
	  (( INDEX | KEY )? LPAREN indexname+=simple_obj_ref_no_alias ( COMMA indexname+=simple_obj_ref_no_alias )* RPAREN )?
	  ( IGNORE LEAVES )?
  ;

reset
  : RESET QUERY CACHE
  ;

create_udf
  : CREATE  ( AGGREGATE )? FUNCTION function_name=simple_obj_ref_no_alias
    RETURNS ( STRING_KEYWORD | INTEGER | REAL | DECIMAL )
    SONAME shared_library_name=STRING_LEX
  ;

install_plugin
  : INSTALL PLUGIN ident SONAME STRING_LEX
  ;

uninstall_plugin
  : UNINSTALL PLUGIN plugin_name=ident
  ;

load_xml
  : { this.mysqlVersion >= 5.5 }? => (
  LOAD XML ( LOW_PRIORITY | CONCURRENT )? LOCAL? INFILE STRING_LEX
  ( REPLACE | IGNORE )?
  INTO TABLE simple_table_ref_no_alias
  partition_ref?
  ( charset_def )?
  ( ROWS IDENTIFIED BY STRING_LEX )?
  ( IGNORE INT_NUMBER ( LINES | ROWS )? )?
  ( LPAREN column_name_list RPAREN )?
  ( SET field_name EQUALS exprList )? )
  ;

signal
  : { this.mysqlVersion >= 5.5 }? =>  
  SIGNAL signal_condition_value
  ( SET signal_information_item ( COMMA signal_information_item )* )?
  ;

signal_information_item
  :  signal_conditiona_information_item_name EQUALS signal_simple_value_specification
  ;

signal_conditiona_information_item_name
  : CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
  ;

signal_simple_value_specification
  :  expr
  ;

signal_condition_value
  : ( SQLSTATE VALUE? sqlstatevalue=STRING_LEX ) | ID
  ;

resignal
  : { this.mysqlVersion >= 5.5 }? =>  
  RESIGNAL signal_condition_value?
  ( SET signal_information_item ( COMMA signal_information_item )* )?
  ;

get_diagnostics
  :  { this.mysqlVersion >= 5.6 }? => (
  ( GET CURRENT? DIAGNOSTICS
  (( CONDITION ( INT_NUMBER | get_diagnostics_target ) 
  get_diagnostics_condition_info_item ( COMMA get_diagnostics_condition_info_item )* ) 
  | ( get_diagnostics_stmt_info_item ( COMMA get_diagnostics_stmt_info_item )* ))
  ))
  ;

get_diagnostics_stmt_info_item
  : get_diagnostics_target EQUALS ( NNUMBER | ROW_COUNT )
  ;

get_diagnostics_target
  : ID | session_variable | global_variable
  ;

get_diagnostics_condition_info_item
  : get_diagnostics_target EQUALS ( CLASS_ORIGIN | SUBCLASS_ORIGIN | RETURNED_SQLSTATE | MESSAGE_TEXT | MYSQL_ERRNO | CONSTRAINT_CATALOG |
  CONSTRAINT_SCHEMA | CONSTRAINT_NAME | CATALOG_NAME | SCHEMA_NAME | TABLE_NAME | COLUMN_NAME | CURSOR_NAME )
  ;

alter_user
  : { this.mysqlVersion >= 5.6 }? /* actually available since ver 5.6.6 */ =>  
  ALTER USER user_specification PASSWORD EXPIRE ( COMMA user_specification PASSWORD EXPIRE )*
  ;