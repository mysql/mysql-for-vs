/* Copyright (c) 2008 MySQL AB, 2009 Sun Microsystems, Inc. All rights reserved. */
parser grammar MySQL51Parser; 

options {
	language=CSharp3;
	output=AST;
	tokenVocab=MySQL51Lexer;
	/*k=*;*/
	/*superClass=MySQLParser;*/
}

tokens {
BEGIN_END;
CASE_STMT;
CHARACTERISTIC;
EXPR;
SELECT_EXPR;
UNARY_MINUS;
UNARY_PLUS;
OPTIONS;
FUNC;
DIRECTION;
ALIAS;
FIELD;
SUBSELECT;
COMMA_JOIN;
COLUMNS;
INSERT_VALUES;
INDEX_HINTS;
ROLLBACK_POINT;	/* rollback to savepoint */
/* token types for the various CREATE statements */
CREATE_TABLE;
/* helper tokens for column definitions  */
NOT_NULL;
DEFINITION;
DEFINITIONS;
COUNT_STAR;
OBJECT_TYPE;
PARAM;
PRIVILEGE_LEVEL;
SET_PASSWORD;
SSL_OPTION;
USER_HOST;
USER_HOST_OR_ID_OR_STRING;
WITH_OPTION;
XID;
}


@namespace{MySql.Parser}



public program
	: statement_list EOF
	;

public statement_list
	:	stmts+=statement (SEMI stmts+=statement)* SEMI*
		-> $stmts+
	;

statement options { backtrack=true; memoize=true; }
	:	(	select
		|	do_stmt
		|	show_stmt
		|	deallocate
		|	describe
		|	execute
		|	explain
		|	grant
		|	insert
		|	update
		|	declare_stmt 
		|	delete		
		|	COMMENT_RULE
		|	create_database
		|	create_function
		|	create_table
		|	create_procedure
		|	create_user
		|	cursor_declare
		|	cursor_open
		|	cursor_fetch
		|	cursor_close
		|	drop_database
		|	drop_event
		|	drop_routine
		|	drop_index
		|	drop_logfile
		|	drop_server
		|	drop_table
		|	drop_trigger
		|	drop_view
		|	drop_user
		|	if_stmt
		|	iterate
		|	help
		|	leave
		|	loop
		|	prepare
		|	rename_database
		|	rename_table
		|	rename_user
		|	repeat
		|	return_stmt
		|	revoke_user
		|	set_stmt
		|	set_password
		|	transaction
		|	truncate_table
		|	begin_end_stmt
		|	sp_call
		|	while
		|	use
		)
	;

// $< DML

begin_end_stmt
	:	( ( beginlabel=ID COLON ) BEGIN declare_stmt* statement_list END ( endlabel=ID )?
		-> ^( BEGIN_END $beginlabel $endlabel? declare_stmt* statement_list ) )
		|
		( BEGIN declare_stmt* statement_list END 
		-> ^( BEGIN_END declare_stmt* statement_list ) )
	;

loop
	:	( ( beginlabel=ID COLON ) LOOP statement_list END LOOP ( endlabel=ID )?
		-> ^( LOOP $beginlabel $endlabel? statement_list ) )
		|
		( LOOP statement_list END LOOP 
		-> ^( LOOP statement_list ) )
	;

repeat
	:	( ( beginlabel=ID COLON ) REPEAT statement_list UNTIL where_condition END REPEAT ( endlabel=ID )?
		-> ^( LOOP $beginlabel $endlabel? statement_list UNTIL where_condition ) )
		|
		( REPEAT statement_list UNTIL where_condition END REPEAT
		-> ^( LOOP statement_list UNTIL where_condition  ) )
	;

while
	:	( ( beginlabel=ID COLON ) WHILE where_condition DO statement_list END WHILE ( endlabel=ID )?
		-> ^( WHILE where_condition $beginlabel $endlabel? statement_list  ) )
		|
		( WHILE where_condition DO statement_list END WHILE
		-> ^( WHILE where_condition statement_list  ) )
	;

create_procedure
	: CREATE ( DEFINER EQUALS ( user_specification | CURRENT_USER ))? 
		PROCEDURE ident LPAREN ( parm+=proc_parameter ( COMMA parm+=proc_parameter )* )? RPAREN 
		( characteristic )* routine_body
		-> ^( CREATE PROCEDURE ( DEFINER user_specification? CURRENT_USER? )? 
			ident $parm? ^( CHARACTERISTIC characteristic* )? routine_body
			) 
	;

create_function
	: CREATE ( DEFINER EQUALS ( user_specification | CURRENT_USER ))? 
		FUNCTION ident LPAREN ( parm+=func_parameter ( COMMA parm+=func_parameter )* )? RPAREN 
		RETURNS data_type
		( characteristic )* routine_body
		-> ^( CREATE FUNCTION ( DEFINER user_specification? CURRENT_USER? )? 
			ident $parm? RETURNS data_type ^( CHARACTERISTIC characteristic* )? routine_body
			) 
	;

proc_parameter
	:	( type=IN | type=OUT | type=INOUT )? ident data_type	
			-> ^( PARAM ident data_type $type? )
	;

func_parameter
	:	ident data_type	-> ^( PARAM ident data_type )
	;

characteristic
	:	COMMENT STRING	-> ^( COMMENT STRING )
	|	LANGUAGE SQL	-> ^( LANGUAGE )
	|	NOT? DETERMINISTIC	-> ^( DETERMINISTIC NOT? )
	|	( ( CONTAINS SQL ) -> ^( CONTAINS )
		| ( NO SQL ) -> ^( NO )
		| ( READS SQL DATA ) -> ^( READS )
		| ( MODIFIES SQL DATA ) -> ^( MODIFIES ))
		
	|	SQL SECURITY ( DEFINER | INVOKER )	-> ^( SQL SECURITY DEFINER? INVOKER? )
	;

routine_body
	:	statement	-> statement	
	;

if_stmt
	:	IF cond+=where_condition THEN condstmt+=statement_list
		( ELSEIF cond+=where_condition THEN condstmt+=statement_list )*
		( ELSE elsestmt=statement_list )?
		END IF
		->	^( IF $cond $condstmt ^( ELSE $elsestmt)? )
	;

/* has to be within a loop, repeat or while statements */
iterate
	:	ITERATE ident	-> ^( ITERATE ident )
	;

/* has to be within a begin-end, loop, repeat or while statements */
leave
	:	LEAVE ident		-> ^( LEAVE ident )
	;

declare_stmt 
	:	DECLARE ident ( COMMA ident )* data_type	-> ^( DECLARE ident* data_type )
	;

set_stmt
	:	SET variable_assignment ( COMMA variable_assignment )*	-> ^( SET variable_assignment+ )
	|	SET ( charset | DEFAULT ) -> ^( SET CHARACTER charset? DEFAULT? )
	|	SET NAMES ( ( ( val=ID | val=STRING ) collate?	) | DEFAULT )
		-> ^( SET NAMES $val? COLLATE collate? DEFAULT? )
	;

variable_assignment
	:	ID EQUALS expr	-> ^( ID expr )
	/* TODO validate vs. the list of system variables */
	|	( GLOBAL | SESSION ) ID EQUALS expr		-> ^( ID expr GLOBAL? SESSION? )
	|	(( AT1 AT1 GLOBAL DOT ) | ( AT1 AT1 SESSION DOT )) ID EQUALS expr	-> ^( ID expr GLOBAL? SESSION? )
	;

create_database
	:	CREATE ( DATABASE | SCHEMA ) ( IF NOT EXISTS )? ident create_specification* 
		-> ^(CREATE { new CommonTree( new CommonToken( DATABASE, "DATABASE" ) ) } ident)
	;

/* This only for functions, must be at least one, not allowed for procedures or triggers. */
return_stmt
	:	RETURN expr	-> ^( RETURN expr )	
	;

do_stmt	:	DO exprList		-> ^(DO exprList)
	;

show_stmt 
  : (SHOW -> ^(SHOW))
    ( AUTHORS     -> ^($show_stmt ^(AUTHORS))
    | BINLOG EVENTS (IN logName=STRING)? (FROM INT_NUMBER)? limit?  -> ^($show_stmt ^(BINLOG $logName? INT_NUMBER? limit?))
    | CHARACTER SET like_or_where?  -> ^($show_stmt ^(CHARACTER like_or_where?))
    | COLLATION like_or_where?    -> ^($show_stmt ^(COLLATION like_or_where?))
    | FULL? COLUMNS (FROM|IN) simple_table_ref_no_alias ((FROM|IN) ident)? like_or_where? -> ^($show_stmt ^(COLUMNS FULL? simple_table_ref_no_alias ident? like_or_where?))
    | CONTRIBUTORS  -> ^($show_stmt ^(CONTRIBUTORS))    
	| CREATE DATABASE ident -> ^($show_stmt ^(CREATE DATABASE ident))
    | CREATE EVENT ident    -> ^($show_stmt ^(CREATE EVENT ident))
    | CREATE FUNCTION ident -> ^($show_stmt ^(CREATE FUNCTION ident))
    | CREATE PROCEDURE ident  -> ^($show_stmt ^(CREATE PROCEDURE ident))
    | CREATE TABLE simple_table_ref_no_alias_existing  -> ^($show_stmt ^(CREATE TABLE simple_table_ref_no_alias_existing))
    | CREATE TRIGGER ident  -> ^($show_stmt ^(CREATE TRIGGER ident))
    | CREATE VIEW ident   -> ^($show_stmt ^(CREATE VIEW ident))
    | DATABASES like_or_where?  -> ^($show_stmt ^(DATABASES like_or_where?))
    | ENGINE (INNODB | ident) (what=STATUS | what=MUTEX) // have to add INNODB token, because of SHOW INNODB STATUS :(
                    -> ^($show_stmt ^(ENGINE INNODB? ident? $what))
    | STORAGE? ENGINES    -> ^($show_stmt ^(ENGINES))
    | ERRORS limit?     -> ^($show_stmt ^(ERRORS limit?))
    | FULL? EVENTS      -> ^($show_stmt ^(EVENTS FULL?))
    | FUNCTION CODE ident   -> ^($show_stmt ^(CODE FUNCTION ident))
    | FUNCTION STATUS like_or_where?  -> ^($show_stmt ^(STATUS FUNCTION like_or_where?))
    | GRANTS FOR
        ( 		  
		  STRING user_host?
		| ID user_host?
        | whom+=CURRENT_USER
        | whom+=CURRENT_USER LPAREN RPAREN
        )         -> ^($show_stmt ^(GRANTS $whom? ID? STRING? user_host? ))
    | INDEX_SYM FROM simple_table_ref_no_alias ((FROM|IN) ident)? -> ^($show_stmt ^(INDEX_SYM simple_table_ref_no_alias ident?))
	/* This is deprecated in MySql 5.1 */
    | INNODB STATUS   -> ^($show_stmt ^(INNODB STATUS))
    | OPEN TABLES ((FROM|IN) ident)? like_or_where? -> ^($show_stmt ^(OPEN ident? like_or_where?))
    | PLUGINS     -> ^($show_stmt ^(PLUGINS))
    | PROCEDURE CODE ident      -> ^($show_stmt ^(CODE PROCEDURE ident))
    | PROCEDURE STATUS like_or_where? -> ^($show_stmt ^(STATUS PROCEDURE ident))
    | PRIVILEGES      -> ^($show_stmt ^(PRIVILEGES))
    | FULL? PROCESSLIST -> ^($show_stmt ^(PROCESSLIST FULL?))
    | ( PROFILE | PROFILES ) ( show_profile_types ( COMMA show_profile_types )* )? (FOR QUERY INT_NUMBER)? limit? -> ^($show_stmt ^( { new CommonTree( new CommonToken( PROFILE, "PROFILE" ) ) }  show_profile_types* INT_NUMBER? limit?))
    /*| PROFILES    -> ^($show_stmt ^(PROFILES)) */
    | SCHEDULER STATUS  -> ^($show_stmt ^(STATUS SCHEDULER))
    | optScopeModifier STATUS like_or_where?  -> ^($show_stmt ^(STATUS optScopeModifier? like_or_where?))
    | TABLE STATUS ((FROM|IN) ident)? like_or_where?      -> ^($show_stmt  ^(STATUS TABLE ident? like_or_where?))
    | TABLES ((FROM|IN) ident)? like_or_where?          -> ^($show_stmt ^(TABLES ident? like_or_where?))
    | TRIGGERS ((FROM|IN) ident)? like_or_where?        -> ^($show_stmt ^(TRIGGERS ident? like_or_where?))
    | optScopeModifier VARIABLES like_or_where?   -> ^($show_stmt ^(VARIABLES optScopeModifier? like_or_where?))
    | WARNINGS limit?   -> ^($show_stmt ^(WARNINGS limit?))
	| SLAVE HOSTS -> ^($show_stmt ^(SLAVE HOSTS))
	| SLAVE STATUS -> ^($show_stmt ^(SLAVE STATUS))
	| MASTER STATUS -> ^($show_stmt ^(MASTER STATUS))
	| BINARY LOGS -> ^($show_stmt ^(BINARY LOGS))
	| MASTER LOGS -> ^($show_stmt ^(MASTER LOGS))	
    )
  ;

create_specification
  : ( DEFAULT )? CHARACTER SET EQUALS? ( ID | STRING )
  | ( DEFAULT )? COLLATE EQUALS? ( ID | STRING )
  ;

optScopeModifier
  : GLOBAL    -> GLOBAL
  | SESSION   -> SESSION
  | l=LOCAL   -> SESSION[$l]
  | /* empty, defaults to SESSION */ -> SESSION
  ;

show_profile_types
  : ALL
  | BLOCK IO
  | CONTEXT SWITCHES
  | CPU
  | IPC
  | MEMORY
  | PAGE FAULTS
  | SOURCE
  | SWAPS
  ;

like_or_where
  : // behold, this is a special LIKE...does not allow expressions on the RHS
    LIKE string_or_placeholder   -> ^(LIKE string_or_placeholder)
  | WHERE expr    -> ^(WHERE expr)
  ;
  
explain
  : EXPLAIN ( EXTENDED | PARTITIONS )? table_factor
	-> ^( EXPLAIN table_factor )  
  ;

help
	:	HELP STRING	-> ^( HELP STRING )
	;

use
	:	USE ID	-> ^( USE ID )
	;

describe
	:	( DESCRIBE | DESC ) tblname=ID ( col=ID | wild=STRING )
			-> ^( { new CommonTree( new CommonToken( TABLE, "TABLE" ) ) } $tblname $col? $wild? )
	;

prepare
	:	PREPARE stmtname=ID FROM prepstmt=SESSION_VARIABLE
			-> ^( PREPARE $stmtname $prepstmt )
	;

deallocate
	:	( DEALLOCATE | DROP ) PREPARE ID	-> 
		^( { new CommonTree( new CommonToken( DEALLOCATE, "DEALLOCATE" ) ) } ID ) 
	;

// Cursors
cursor_close
	:	CLOSE ID	-> ^( CLOSE ID )
	;

cursor_declare
	:	DECLARE ID CURSOR FOR select	-> ^( DECLARE ID CURSOR select )
	;

cursor_fetch
	:	FETCH curname=ID INTO var+=ID ( COMMA var+=ID )*	
			-> ^( FETCH $curname $var )
	;

cursor_open
	:	OPEN ID	-> ^( OPEN ID )
	;

execute
	:	EXECUTE ID ( USING vars+=SESSION_VARIABLE ( COMMA vars+=SESSION_VARIABLE )* )?	
			->	^( EXECUTE ID $vars? ) 
	;

select
@init {
bool seenUnion = false;
}
	:	select_paren
		(UNION (mod=ALL | mod=DISTINCT)? union_selects+=select {seenUnion=true;})*
		 	-> {seenUnion}? ^(UNION $mod? select_paren $union_selects+)
			-> select_paren
	;

select_paren 
	:	LPAREN select_paren RPAREN	 -> select_paren
	|	select_inner 	-> select_inner
	;
	catch[ NoViableAltException nvae ] 
	{
		if( nvae.DecisionNumber == 65 )
		{
			nvae = new NoViableAltException( 
					"column_name", 
					65 /* re.DecisionNumber */, 
					0 /* re.StateNumber*/, 
					nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

select_inner
	:	SELECT (options{k=1;}:select_options)*
		exprs+=select_expr (COMMA exprs+=select_expr)*
		( { input.LT(1).Text.ToLower() == "from" }?
            (FROM table_references)
            (WHERE where=where_condition)?
            group_by?
            (HAVING having=where_condition)?
            order_by?
            limit?
            // these procedures are not "SQL-SPs" but C++ ones. very unlikely that we'll see them.
            (PROCEDURE procId=ident procArgs=parenOptExprList)?
            /* TODO: what is allowed in the "STRING" below? probably not N'foobar' etc. */
            ((	INTO OUTFILE file=STRING opts=infile_options_helper
                |	INTO DUMPFILE file=STRING
                |	INTO vars+=variable (COMMA vars+=variable)*
                )	
            )?
            (forUpdate=FOR UPDATE | clock=LOCK IN SHARE MODE)?
        |   order_by
            limit?
        |   limit
		)?
		-> ^(SELECT 
				^(OPTIONS select_options*)?
				^(COLUMNS $exprs+)
				^(FROM table_references)?
				^(WHERE $where)?
				group_by?
				^(HAVING $having)?
				order_by?
				limit?
				FOR?
				LOCK?
			)
	;
	catch[ NoViableAltException nvae ] 
	{
		if( nvae.Token.Text == "<EOF>" ) {
			nvae = new NoViableAltException( 
				"column_name", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}	

infile_options_helper
	:	(	(COLUMNS|FIELDS)
			(TERMINATED BY fieldTerm=STRING)?
			(optEnclosed=OPTIONALLY? ENCLOSED BY fieldEncl=STRING)?			/* TODO: STRING here is one character, really */
			(ESCAPED BY fieldEsc=STRING)?									/* TODO: STRING here is one character, really */
		)?
		(	LINES
			(STARTING BY linesStart=STRING)?
			(TERMINATED BY linesTerm=STRING)?
		)?
	;
	
variable
	:	SESSION_VARIABLE
	|	GLOBAL_VARIABLE
	;

limit
	:	LIMIT
			(	((offset=number_or_placeholder COMMA)? lim=number_or_placeholder)	
			| 	(lim=number_or_placeholder offsetForm=OFFSET offset=number_or_placeholder)
			)
		-> ^(LIMIT $lim $offset? $offsetForm?)
	;

string_or_placeholder
	:	STRING
	|	VALUE_PLACEHOLDER
	;

number_or_placeholder
	:	INT_NUMBER
	|	VALUE_PLACEHOLDER
	;

text_string
	:	STRING
	|	BINARY_VALUE
	|	HEXA_VALUE
	;

group_by
	:	GROUP BY 
			elements+=order_group_by_elements (COMMA elements+=order_group_by_elements )*
		(rollup=WITH ROLLUP)?
		-> ^(GROUP $elements+ $rollup?)
	;

order_by
	:	ORDER BY
			elements+=order_group_by_elements (COMMA elements+=order_group_by_elements )*
		-> ^(ORDER $elements+)
	;
	
order_group_by_elements
	:	expr 
		(	asc=ASC						-> ^(DIRECTION[$asc] expr)
		|	desc=DESC					-> ^(DIRECTION[$desc] expr)
		|	/* implicit ASC */			-> ^(DIRECTION["ASC"] expr)
		)
	;

select_options
	:	ALL
	|	DISTINCT
	|	DISTINCTROW
	|	HIGH_PRIORITY
	|	STRAIGHT_JOIN
	|	SQL_SMALL_RESULT
	|	SQL_BIG_RESULT
	|	SQL_BUFFER_RESULT
	|	SQL_CACHE
	|	SQL_NO_CACHE
	|	SQL_CALC_FOUND_ROWS
	;
	
select_expr
	:	star=MULT				-> ^(SELECT_EXPR $star)
	|	expr (AS? ident)?		-> ^(SELECT_EXPR expr ^(ALIAS ident)?)
	;
	catch[ NoViableAltException nvae ] 
	{
		nvae = new NoViableAltException( 
			"column_name", 
			nvae.DecisionNumber /* re.DecisionNumber */, 
			0 /* re.StateNumber*/, 
			nvae.Input );		
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

/*	catch[RecognitionException re] {
	   Object errorNode = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
	   Object root_1 = (Object)adaptor.nil();
     root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECT_EXPR, "SELECT_EXPR"), root_1);
     adaptor.addChild(root_1, errorNode);
     adaptor.addChild(root_0, root_1);
     retval.tree = (Object)adaptor.rulePostProcessing(root_0);
	}
*/
table_references returns [int table_count]
scope {
int count;
}
@init {
$table_references::count = 0;
}
@after {
$table_references.table_count = $table_references::count;
}
	:	(	t1=table_ref 			-> $t1)
		(	COMMA t2=table_ref		-> ^(COMMA_JOIN[$COMMA] $table_references $t2)
		)*
	;

/* left factored to get rid of the recursion */
table_ref
	:	(t1=table_factor -> $t1 )
		(
			(LEFT|RIGHT)=>(ltype=LEFT|ltype=RIGHT) outer=OUTER? JOIN t3=table_ref lrjoinCond=join_condition_both 
				-> ^($ltype {$tree} $t3 $lrjoinCond $outer?)
		|	(type=INNER|type=CROSS)? JOIN t2=table_factor cond1=join_condition_both? 
				-> ^(JOIN {$tree} $t2 $cond1? $type?)
		|	(	type=STRAIGHT_JOIN t2=table_factor 
				(	(join_condition_on)=> cond2=join_condition_on	-> ^($type {$tree} $t2 $cond2)
				|							-> ^($type {$tree} $t2)
				)
			)
		|	(NATURAL)=> NATURAL ((type=LEFT|type=RIGHT) outer=OUTER?)? JOIN t2=table_factor -> ^(NATURAL $type? {$tree} $t2 $outer?)
		)*
	;
	
table_factor
	:	simple_table_ref_alias index_hint_list? {$table_references::count++;} -> ^(TABLE simple_table_ref_alias index_hint_list?)
	|	LPAREN select_inner RPAREN AS? ident		{$table_references::count++;} -> ^(SUBSELECT select_inner ^(ALIAS ident))
    |   LPAREN table_ref {$table_references::count++;} (COMMA table_ref {$table_references::count++;} )* RPAREN   -> ^(TABLE table_ref+)
	/* ident in the following should really by 'OJ', but the parser accepts any identifier in its place 
	|	LCURLY ident t1=table_ref LEFT OUTER JOIN t2=table_ref join_condition_on RCURLY 
			-> ^(ident $t1 $t2 join_condition_on) */
	/* The definition the syntax for ODBC is taken from the rule 'esc_table_ref' in file sql_yacc.yy,
		the previously commented out definition is ambiguous with table_ref rule.
	 */
	| LCURLY ident table_ref RCURLY			-> ^(TABLE table_ref)
	|	DUAL								-> ^(DUAL)
	;
	catch[ NoViableAltException nvae ] 
	{
		nvae = new NoViableAltException( 
				( new System.Diagnostics.StackTrace( true ).GetFrame( 0 ).GetMethod().GetCustomAttributes(true)[ 0 ] as 
				GrammarRuleAttribute ).Name, 0/* nvae.DecisionNumber */, 0 /* nvae.StateNumber*/, nvae.Input );		
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

join_condition_on
	:	ON where_condition		-> ^(ON where_condition)
	;

join_condition_both
	:	join_condition_on
	|	USING LPAREN fields+=ident (COMMA fields+=ident)* RPAREN		-> ^(USING $fields+)
	;

simple_obj_ref_no_alias
	:	first=ident (DOT second=ident)?		-> $first $second?	
	/*|	DOT ident					/* TODO: No AST for this subrule? */
	;

simple_table_ref_no_alias
	:	first=ident (DOT second=ident)?		-> $first $second?
	;

simple_table_ref_no_alias_existing
	:	simple_table_ref_no_alias
	;

simple_table_ref_alias
	:	first=ident (DOT second=ident)? table_alias?		-> $first $second? table_alias?
	;

table_alias
	:	AS? alias=ident	-> ^(ALIAS $alias)
	;

field_name
@init {
int i = 0;
bool seenStar = false;
}
	:	ident
		({seenStar == false}?=> 
		  (DOT 
		    ({seenStar == false}? (ident | star=MULT {seenStar = true;}) {++i <= 2}?)
		  )*
		)
		-> ^(FIELD ident+ $star?)//	|	(DOT)=>DOT column=field_name_column	-> ^(FIELD $column)
	;

/* list all keywords that can also be used as an identifier
   This list is taken from the 5.1 YACC grammar 
*/

ident
	:	
	(	tok=ASCII
	|	tok=BACKUP
	|	tok=BEGIN
	|	tok=BYTE
	|	tok=CACHE
	|	tok=CHARSET
	|	tok=CHECKSUM
	|	tok=CLOSE
	|	tok=COMMENT
	|	tok=COMMIT
	|	tok=CONTAINS
	|	tok=DEALLOCATE
	|	tok=DO
	|	tok=END
	|	tok=EXECUTE
	|	tok=FLUSH
	|	tok=GROUP
	|	tok=HANDLER
	|	tok=HELP
	|	tok=HOST
	|	tok=INSTALL
	|	tok=LABEL
	|	tok=LANGUAGE
	|	tok=NO
	|	tok=OPEN
	|	tok=OPTIONS
	|	tok=OWNER
	|	tok=PARSER
	|	tok=PARTITION
	|	tok=PORT
	|	tok=PREPARE
	|	tok=REMOVE
	|	tok=REPAIR
	|	tok=RESET
	|	tok=RESTORE
	|	tok=ROLLBACK
	|	tok=SAVEPOINT
	|	tok=SECURITY
	|	tok=SERVER
	|	tok=SIGNED
	|	tok=SOCKET
	|	tok=SLAVE
	|	tok=SONAME
	|	tok=START
	|	tok=STOP
	|	tok=TRUNCATE
	|	tok=UNICODE
	|	tok=UNINSTALL
	|	tok=WRAPPER
	|	tok=XA
	|	tok=UPGRADE
	)	-> ID[$tok]
	|	ident_sp_label	-> {$ident_sp_label.tree}
	;
	catch[ NoViableAltException nvae ] 
	{
		if( simple_table_ref_no_alias_existing_cnt > 0 )
		{
			nvae = new NoViableAltException( 
				"simple_table_ref_no_alias_existing", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		} else if( Scope.Peek() == "field_name" ) {
			nvae = new NoViableAltException( 
				"column_name", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

ident_sp_label
	:		
	(	tok=ID!
	|	tok=ACTION!
	|	tok=ADDDATE!
	|	tok=AFTER!
	|	tok=AGAINST!
	|	tok=AGGREGATE!
	|	tok=ALGORITHM!
	|	tok=ANY!
	|	tok=AT!
	|	tok=AUTHORS!
	|	tok=AUTO_INCREMENT!
	|	tok=AUTOEXTEND_SIZE!
	|	tok=AVG_ROW_LENGTH!
	|	tok=AVG!
	|	tok=BINLOG!
	|	tok=BIT!
	|	tok=BLOCK!
	|	tok=BOOL!
	|	tok=BOOLEAN!
	|	tok=BTREE!
	|	tok=CASCADED!
	|	tok=CHAIN!
	|	tok=CHANGED!
	|	tok=CIPHER!
	|	tok=CLIENT!
	|	tok=COALESCE!
	|	tok=CODE!
	|	tok=COLLATION!
	|	tok=COLUMNS!
	|	tok=FIELDS!
	|	tok=COMMITTED!
	|	tok=COMPACT!
	|	tok=COMPLETION!
	|	tok=COMPRESSED!
	|	tok=CONCURRENT!
	|	tok=CONNECTION!
	|	tok=CONSISTENT!
	|	tok=CONTEXT!
	|	tok=CONTRIBUTORS!
	|	tok=CPU!
	|	tok=CUBE!
	|	tok=DATA!
	|	tok=DATAFILE!
	|	tok=DATETIME!
	|	tok=DATE!
	|	tok=DAY!
	|	tok=DEFINER!
	|	tok=DELAY_KEY_WRITE!
	|	tok=DES_KEY_FILE!
	|	tok=DIRECTORY!
	|	tok=DISABLE!
	|	tok=DISCARD!
	|	tok=DISK!
	|	tok=DUMPFILE!
	|	tok=DUPLICATE!
	|	tok=DYNAMIC!
	|	tok=ENDS!
	|	tok=ENUM!
	|	tok=ENGINE!
	|	tok=ENGINES!
	|	tok=ERRORS!
	|	tok=ESCAPE!
	|	tok=EVENT!
	|	tok=EVENTS!
	|	tok=EVERY!
	|	tok=EXPANSION!
	|	tok=EXTENDED!
	|	tok=EXTENT_SIZE!
	|	tok=FAULTS!
	|	tok=FAST!
	|	tok=FOUND!
	|	tok=ENABLE!
	|	tok=FULL!
	|	tok=FILE!
	|	tok=FIRST!
	|	tok=FIXED!
	|	tok=FRAC_SECOND!
	|	tok=GEOMETRY!
	|	tok=GEOMETRYCOLLECTION!
	|	tok=GET_FORMAT!
	|	tok=GRANTS!
	|	tok=GLOBAL!
	|	tok=HASH!
	|	tok=HOSTS!
	|	tok=HOUR!
	|	tok=IDENTIFIED!
	|	tok=INVOKER!
	|	tok=IMPORT!
	|	tok=INDEXES!
	|	tok=INITIAL_SIZE!
	|	tok=IO!
	|	tok=IPC!
	|	tok=ISOLATION!
	|	tok=ISSUER!
	|	tok=INNOBASE!
	|	tok=INSERT_METHOD!
	|	tok=KEY_BLOCK_SIZE!
	|	tok=LAST!
	|	tok=LEAVES!
	|	tok=LESS!
	|	tok=LEVEL!
	|	tok=LINESTRING!
	|	tok=LIST!
	|	tok=LOCAL!
	|	tok=LOCKS!
	|	tok=LOGFILE!
	|	tok=LOGS!
	|	tok=MAX_ROWS!
	|	tok=MASTER!
	|	tok=MASTER_HOST!
	|	tok=MASTER_PORT!
	|	tok=MASTER_LOG_FILE!
	|	tok=MASTER_LOG_POS!
	|	tok=MASTER_USER!
	|	tok=MASTER_PASSWORD!
	|	tok=MASTER_SERVER_ID!
	|	tok=MASTER_CONNECT_RETRY!
	|	tok=MASTER_SSL!
	|	tok=MASTER_SSL_CA!
	|	tok=MASTER_SSL_CAPATH!
	|	tok=MASTER_SSL_CERT!
	|	tok=MASTER_SSL_CIPHER!
	|	tok=MASTER_SSL_KEY!
	|	tok=MAX_CONNECTIONS_PER_HOUR!
	|	tok=MAX_QUERIES_PER_HOUR!
	|	tok=MAX_SIZE!
	|	tok=MAX_UPDATES_PER_HOUR!
	|	tok=MAX_USER_CONNECTIONS!
	|	tok=MAX_VALUE!
	|	tok=MEDIUM!
	|	tok=MEMORY!
	|	tok=MERGE!
	|	tok=MICROSECOND!
	|	tok=MIGRATE!
	|	tok=MINUTE!
	|	tok=MIN_ROWS!
	|	tok=MODIFY!
	|	tok=MODE!
	|	tok=MONTH!
	|	tok=MULTILINESTRING!
	|	tok=MULTIPOINT!
	|	tok=MULTIPOLYGON!
	|	tok=MUTEX!
	|	tok=NAME!
	|	tok=NAMES!
	|	tok=NATIONAL!
	|	tok=NCHAR!
	|	tok=NDBCLUSTER!
	|	tok=NEXT!
	|	tok=NEW!
	|	tok=NO_WAIT!
	|	tok=NODEGROUP!
	|	tok=NONE!
	|	tok=NVARCHAR!
	|	tok=OFFSET!
	|	tok=OLD_PASSWORD!
	|	tok=ONE_SHOT!
	|	tok=ONE!
	|	tok=PACK_KEYS!
	|	tok=PAGE!
	|	tok=PARTIAL!
	|	tok=PARTITIONING!
	|	tok=PARTITIONS!
	|	tok=PASSWORD!
	|	tok=PHASE!
	|	tok=PLUGIN!
	|	tok=PLUGINS!
	|	tok=POINT!
	|	tok=POLYGON!
	|	tok=PRESERVE!
	|	tok=PREV!
	|	tok=PRIVILEGES!
	|	tok=PROCESS!
	|	tok=PROCESSLIST!
	|	tok=PROFILE!
	|	tok=PROFILES!
	|	tok=QUARTER!
	|	tok=QUERY!
	|	tok=QUICK!
	|	tok=REBUILD!
	|	tok=RECOVER!
	|	tok=REDO_BUFFER_SIZE!
	|	tok=REDOFILE!
	|	tok=REDUNDANT!
	|	tok=RELAY_LOG_FILE!
	|	tok=RELAY_LOG_POS!
	|	tok=RELAY_THREAD!
	|	tok=RELOAD!
	|	tok=REORGANIZE!
	|	tok=REPEATABLE!
	|	tok=REPLICATION!
	|	tok=RESOURCES!
	|	tok=RESUME!
	|	tok=RETURNS!
	|	tok=ROLLUP!
	|	tok=ROUTINE!
	|	tok=ROWS!
	|	tok=ROW_FORMAT!
	|	tok=ROW!
	|	tok=RTREE!
	|	tok=SCHEDULE!
	|	tok=SECOND!
	|	tok=SERIAL!
	|	tok=SERIALIZABLE!
	|	tok=SESSION!
	|	tok=SIMPLE!
	|	tok=SHARE!
	|	tok=SHUTDOWN!
	|	tok=SNAPSHOT!
	|	tok=SOUNDS!
	|	tok=SOURCE!
	|	tok=SQL_CACHE!
	|	tok=SQL_BUFFER_RESULT!
	|	tok=SQL_NO_CACHE!
	|	tok=SQL_THREAD!
	|	tok=STARTS!
	|	tok=STATUS!
	|	tok=STORAGE!
	|	tok=STRING_KEYWORD!
	|	tok=SUBDATE!
	|	tok=SUBJECT!
	|	tok=SUBPARTITION!
	|	tok=SUBPARTITIONS!
	|	tok=SUPER!
	|	tok=SUSPEND!
	|	tok=SWAPS!
	|	tok=SWITCHES!
	|	tok=TABLES!
	|	tok=TABLESPACE!
	|	tok=TEMPORARY!
	|	tok=TEMPTABLE!
	|	tok=TEXT!
	|	tok=THAN!
	|	tok=TRANSACTION!
	|	tok=TRANSACTIONAL!
	|	tok=TRIGGERS!
	|	tok=TIMESTAMP!
	|	tok=TIMESTAMP_ADD!
	|	tok=TIMESTAMP_DIFF!
	|	tok=TIME!
	|	tok=TYPES!
	|	tok=TYPE!
	|	tok=UDF_RETURNS!
	|	tok=FUNCTION!
	|	tok=UNCOMMITTED!
	|	tok=UNDEFINED!
	|	tok=UNDO_BUFFER_SIZE!
	|	tok=UNDOFILE!
	|	tok=UNKNOWN!
	|	tok=UNTIL!
	|	tok=USER!
	|	tok=USE_FRM!
	|	tok=VARIABLES!
	|	tok=VIEW!
	|	tok=VALUE!
	|	tok=WARNINGS!
	|	tok=WAIT!
	|	tok=WEEK!
	|	tok=WORK!
	|	tok=X509!
	|	tok=YEAR!
	)	
	{
		adaptor.AddChild(root_0, (object)adaptor.Create(ID, $tok));
	}
	;

index_hint_list
	:	index_hint (COMMA index_hint)*		-> ^(INDEX_HINTS index_hint+)
	;

index_hint
scope {
bool namesOptional;
}
@init {
$index_hint::namesOptional = false;
}
	:	USE {$index_hint::namesOptional = true;} index_hint_rest		-> ^(USE index_hint_rest)
	|	IGNORE {$index_hint::namesOptional = false;} index_hint_rest	-> ^(IGNORE index_hint_rest)
	|	FORCE {$index_hint::namesOptional = false;} index_hint_rest	-> ^(FORCE index_hint_rest)
	;

index_hint_rest
	:	(name=INDEX|name=KEY) (FOR (usage=JOIN | usage=ORDER BY | usage=GROUP BY))?
		LPAREN
		( {$index_hint::namesOptional == true}?=> (names+=ident (COMMA names+=ident)*)?
		| names+=ident (COMMA names+=ident)* 
		)
		RPAREN
		-> $name ^(LPAREN $names?) $usage?
	;
// $<Expressions

exprList
	:	e+=expr (COMMA e+=expr)*	-> ^( EXPR $e+ )
	;

parenExpr
	:	LPAREN expr RPAREN	-> ^(LPAREN expr)
	;
	
parenExprList
	:	LPAREN exprList RPAREN	-> ^(LPAREN exprList)
	;
	
parenOptExprList
	:	LPAREN e+=exprList? RPAREN	-> ^(LPAREN $e*)
	;

expr
	:	lhs=assignOrExpr (op=ASSIGN^ rhs=expr)?
	;

assignOrExpr
	:	lhs=assignXORExpr ((op+=LOGICAL_OR^ | op+=OR^) rhs+=assignXORExpr)*
	;

assignXORExpr
	:	lhs=assignAndExpr (op+=XOR^ rhs+=assignAndExpr)*
	;

assignAndExpr
	:	lhs=assignNotExpr (( op+=LOGICAL_AND^ | op+=AND^ ) rhs+=assignNotExpr)*
	;

assignNotExpr
	:	lhs=equalityExpr
	|	op+=NOT^ rhs+=equalityExpr
	;
	catch[ NoViableAltException nvae ] 
	{
		if( Scope.Peek() == "expr" ) {
			nvae = new NoViableAltException( 
				"column_name", 
				0/* re.DecisionNumber */, 
				0 /* re.StateNumber*/, 
				nvae.Input );
		}
		ReportError(nvae);
		Recover(input,nvae);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), nvae);
	}
	catch [RecognitionException re]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
	}

equalityExpr
	:	bitwiseOrExpr
		(op+=equalityOperator^ ((subselect_in_expr_rhs)=> subselect_in_expr_rhs | bitwiseOrExpr))*
	;

subselect_in_expr_rhs
	:	(mod=ANY | mod=SOME | mod=ALL) LPAREN select RPAREN	-> ^(SUBSELECT $mod select)
	;
	
subselect
	:	LPAREN select_inner RPAREN	-> ^(SUBSELECT select_inner)
	;

isOperator
	:	IS NOT? (value2=NULL | value2=FALSE | value2=TRUE | value2=UNKNOWN)	-> ^(IS NOT? $value2)
	;

equalityOperator
	:	(	value=EQUALS
		|	value=NOT_EQUAL
		|	value=LESS_THAN
		|	value=LESS_THAN_EQUAL
		|	value=GREATER_THAN
		| 	value=GREATER_THAN_EQUAL
		|	value=NULL_SAFE_NOT_EQUAL
		| 	value=REGEXP
		|	value=BETWEEN
		/*		
		|	value=CASE
		|	value=WHEN
		|	value=THEN
		|	value=ELSE
		*/
		) -> $value
	;

bitwiseOrExpr
  : lhs=bitwiseAndExpr 
    ( (op+=BITWISE_OR^ rhs+=bitwiseAndExpr)+
    | ((NOT^)? IN^ (parenExprList | subselect))
    | LIKE^ unaryExpr (ESCAPE STRING)?  // STRING must be empty or one character long (or be "\\" if not in sql_mode NO_BACKSLASH_ESCAPES)
	| BETWEEN^ bitwiseAndExpr AND! bitwiseOrExpr
	| SOUNDS^ LIKE bitwiseAndExpr
    | isOperator^
    )?
  ;

bitwiseAndExpr
	:	lhs=shiftExpr (op+=BITWISE_AND^ rhs+=shiftExpr)*
	;

shiftExpr
	:	lhs=additiveExpr ((op+=LEFT_SHIFT^ | op+=RIGHT_SHIFT^) rhs+=additiveExpr)*
	;

/* this is ugly because of INTERVAL:
   As rightmost in an expression, it has the highest precendence.
   Otherwise it must be followed by PLUS|MINUS.
   TODO: It cannot be on the left of a MINUS, because that expression makes no sense.
*/
additiveExpr
	:	lhs=multiplicativeExpr ((op+=PLUS^|op+=MINUS^) rhs+=multiplicativeExpr)*
	;

multOperator
	:(	value=MULT
	|	value=DIVISION
	|	value=DIV
	|	value=MODULO ) -> $value
	;

multiplicativeExpr
	:	lhs=bitwiseXORExpr (op+=multOperator^ rhs+=bitwiseXORExpr)*
	;

bitwiseXORExpr
	:	lhs=unaryExpr (op+=BITWISE_XOR^ rhs+=unaryExpr)*
	;

unaryExpr
	:	op=MINUS lhs=unaryExpr	-> ^(UNARY_MINUS[$op] $lhs)
	|	op=PLUS lhs=unaryExpr	-> ^(UNARY_PLUS[$op] $lhs)
	|	op=BITWISE_INVERSION lhs=unaryExpr -> ^(BITWISE_INVERSION $lhs)
	|	lhsUnaryNot=unaryNotExpr	-> unaryNotExpr
	;
	
unaryNotExpr
	:	op=NOT_OP lhs=unaryNotExpr	-> ^(NOT_OP $lhs)
	|	lhsBin=binaryCollateExpr	-> binaryCollateExpr
	;

binaryCollateExpr
	:	op=BINARY lhs=binaryCollateExpr		-> ^(BINARY $lhs)
	|	op=COLLATE lhs=binaryCollateExpr	-> ^(COLLATE $lhs)
	|	intervalExpr
	;

/* INTERVAL can bind extremely closely, if used as the rightmost subexpr of an expression, otherwise it is in additiveExpr 
   the validating predicate disallows its usage all by itself (can't select just an interval, it must be used in an additive expr)
   defer checking that to a semantic tree phase.
*/
intervalExpr
	:	(INTERVAL ~(LPAREN))=> INTERVAL expr timeUnit {input.LA(1) == PLUS || input.LA(1) == MINUS}? -> ^(INTERVAL expr timeUnit)
	|	lhsPrim=primary	-> primary
	;
	
primary 
	:	/*lhsParen=parenExpr -> parenExpr */
		( lhsLit=literal )	=> literal	-> literal
	|	( subselect )	=> subselect
	|	EXISTS subselect -> ^(EXISTS subselect)
/*	|	functionCall */
/*	|	primary COLLATE ident*/
	|  param_marker -> param_marker
	/*| variable */
	| BINARY primary -> ^( BINARY primary )
	|	ident	-> ident
	| LPAREN exprList RPAREN	-> exprList
	| ROW LPAREN exprList RPAREN	-> exprList
	| LCURLY ident expr RCURLY	-> ^( ident expr )
	| match_expr	-> match_expr
	| case_expr		-> case_expr
	// TODO: add missing primary expressions, like ROW, DEFAULT etc.
	;

param_marker
	: VALUE_PLACEHOLDER ident -> ^( VALUE_PLACEHOLDER ident )
	;

match_expr
	:	MATCH LPAREN column_name_list RPAREN AGAINST LPAREN expr 
	(( IN BOOLEAN MODE ) | ( WITH QUERY EXPANSION ))? RPAREN
	-> ^( MATCH column_name_list expr ( IN BOOLEAN MODE )? ( WITH QUERY EXPANSION )? )
	;

case_expr
	: CASE 	 
		( ( WHEN ( expr ) => whenExpr+=expr THEN thenExpr+=expr )+ 
		( { input.LA(1) == ELSE }? ELSE elseExpr=expr )? END )
		-> ^( CASE ^( WHEN $whenExpr $thenExpr ) ( ELSE $elseExpr )? )
	;

/*
case_expr
	: CASE 	 
		( ( WHEN ( expr ) => expr THEN ( expr ) => expr )+ ( ELSE expr END ))
	|	( expr ( WHEN expr THEN expr )+ ( ELSE expr )? END )
	;
*/

case_stmt
	:	CASE 
		( ( WHEN whenExpr+=expr THEN thenStmt+=statement_list )+ 
		  ( ELSE elseStmt+=statement_list )? END ) 
		-> ^( WHEN $whenExpr $thenStmt $elseStmt? )
	|	( firstPri=primary 
			( WHEN whenPri+=primary THEN thenStmt+=statement_list )+ 
			( ELSE elseStmt+=statement_list )? END CASE )
		-> ^( CASE_STMT $firstPri ^( WHEN $whenPri $thenStmt ) ^( ELSE $elseStmt )? )
	;

literal
	:	STRING^
	|	NUMBER^
	|	INT_NUMBER^
	|	GLOBAL_VARIABLE^
	|	SESSION_VARIABLE^
	|	VALUE_PLACEHOLDER^
	|	BINARY_VALUE^
	|	HEXA_VALUE^
	|	NULL^
	|	TRUE^
	|	FALSE^
	|	(functionCall)=>functionCall	
		-> ^( { new CommonTree( new CommonToken( FUNCTION, "FUNCTION" ) ) } functionCall )
	|	field_name^
	;
// $>

cast_data_type
	:	BINARY (LPAREN INT_NUMBER RPAREN)?	-> ^( BINARY INT_NUMBER? )
	|	CHAR (LPAREN INT_NUMBER RPAREN)?	-> ^( CHAR INT_NUMBER? )
	|	DATE^
	|	DATETIME^
	|	TIME^
	|	DECIMAL	(LPAREN num1=INT_NUMBER COMMA num2=INT_NUMBER RPAREN)?
		-> ^( DECIMAL $num1? $num2? )
	|	SIGNED INTEGER?		-> SIGNED
	|	UNSIGNED INTEGER?	-> UNSIGNED
	;
	
timeUnit
	: (	unit=MICROSECOND
	|	unit=SECOND
	|	unit=MINUTE
	|	unit=HOUR
	|	unit=DAY
	|	unit=WEEK
	|	unit=MONTH
	|	unit=QUARTER
	|	unit=YEAR
	|	unit=SECOND_MICROSECOND
	|	unit=MINUTE_MICROSECOND
	|	unit=MINUTE_SECOND
	|	unit=HOUR_MICROSECOND
	|	unit=HOUR_SECOND
	|	unit=HOUR_MINUTE
	|	unit=DAY_MICROSECOND
	|	unit=DAY_SECOND
	|	unit=DAY_MINUTE
	|	unit=DAY_HOUR
	|	unit=YEAR_MONTH ) -> $unit
	;

/* TODO: add the SQL_TSI_ prefix versions */
timestampUnit
	:	FRAC_SECOND^
	|	MICROSECOND^
	|	SECOND^
	|	MINUTE^
	|	HOUR^
	|	DAY^
	|	WEEK^
	|	MONTH^
	|	QUARTER^
	|	YEAR^
	;
	
where_condition
	:	expr	-> expr
	;

// $< Transactions

/* generates bogus warning about RELEASE */
transaction
	// general trx statements
	:	(	BEGIN  WORK?										-> ^(BEGIN WORK?)
		|	START TRANSACTION (WITH CONSISTENT SNAPSHOT)?		-> ^(START SNAPSHOT?)
		)		
	|	commit
	|	rollback
	// NUMBER must be (0 | 1), no grammar checks done at this point, TODO check AUTOCOMMIT vs keywords/identifiers
	|	SET AUTOCOMMIT EQUALS 
		( { input.LT( 1 ).Text == "1" || input.LT( 1 ).Text == "0" }? => INT_NUMBER)
	|	SET 
		(	txnScope=GLOBAL 
		|	txnScope=SESSION 
		)?
		TRANSACTION ISOLATION LEVEL
		(	READ UNCOMMITTED			-> ^(ISOLATION UNCOMMITTED $txnScope? )
		|	READ COMMITTED				-> ^(ISOLATION COMMITTED $txnScope? )	
		|	REPEATABLE READ				-> ^(ISOLATION REPEATABLE $txnScope? )
		|	SERIALIZABLE				-> ^(ISOLATION SERIALIZABLE $txnScope? )	
		)
	|	savepoint
	|	lockTables	
	| xa
	;

commit
	:	
		/*
		The following natural definition doesn't do the trick, for inputs like "commit no release":
		COMMIT WORK?
			(AND NO? CHAIN)?
			(NO? RELEASE)?					-> ^(COMMIT ^(CHAIN NO?)? ^(RELEASE NO?)?)

		(basically AST rewrite rule doesn't use lookahead of more than one)
		*/
		COMMIT WORK?
		(
			(AND NO? CHAIN) (NO? RELEASE)?				-> ^(COMMIT ^(CHAIN NO?) ^(RELEASE NO?)?)
		|	(NO? RELEASE)								-> ^(COMMIT ^(RELEASE NO?))
		|												-> ^(COMMIT)
		)
	;

rollback
	:	ROLLBACK WORK?
		(
			(AND NO? CHAIN) (NO? RELEASE)?				-> ^(ROLLBACK ^(CHAIN NO?) ^(RELEASE NO?)?)
		|	(NO? RELEASE)								-> ^(ROLLBACK ^(RELEASE NO?))
		|	TO SAVEPOINT? ident							-> ^(ROLLBACK_POINT ident)
		/* savepoint syntax */
		|												-> ^(ROLLBACK)
		)
	;

// savepoint handling
savepoint
	:	RELEASE? SAVEPOINT ident				-> ^(SAVEPOINT ident RELEASE?)	
	;

xa
	:	XA 
	(
		( ( START | BEGIN ) xid ( JOIN | RESUME ) ) -> 
		^( { new CommonTree( new CommonToken( START, "START" ) ) } xid JOIN? RESUME? )
	|	( END xid ( SUSPEND ( FOR MIGRATE )? )?)	-> ^( END xid ( SUSPEND ( FOR MIGRATE )? )? )
	|	( PREPARE xid )								-> ^( PREPARE xid )
	|	( COMMIT xid ( ONE PHASE )? )				-> ^( COMMIT xid )
	|	( ROLLBACK xid )							-> ^( ROLLBACK xid )
	|	( RECOVER )									-> ^( RECOVER )
	)
	;

xid
	:	( gtrid=STRING | gtrid=HEX_VALUE | gtrid=BINARY_VALUE ) 
			( COMMA ( bqual=STRING | bqual=HEX_VALUE | bqual=BINARY_VALUE ) ( COMMA INT_NUMBER )?)?	
		-> ^( XID $gtrid $bqual? INT_NUMBER? )
	;


// $> Transactions

// $< Insert

insert
	:	INSERT (opt=LOW_PRIORITY | opt=DELAYED | opt=HIGH_PRIORITY)?
		IGNORE? INTO?
		table=simple_table_ref_no_alias_existing
		(	insert_columns ( select | insert_values )
		|	set_columns
		)
		on_dup_key?
		-> ^(INSERT IGNORE? INTO? $opt? ^(TABLE $table)
			insert_columns?
			set_columns?
			select?
			on_dup_key?)
	;
	catch[ RecognitionException re ]
	{
		ReportError(re);
		Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
		/*
		 * This tweak fixes the case when there is a syntax error, and the subtree with the table info 
		 * is not included in the tree result (necessary for intellisense).
		 */
		if( table != null )
		{
			object root_1 = (object)adaptor.Nil();			
			root_1 = (object)adaptor.BecomeRoot(table.Tree, root_1);
			object root_2 = (object)adaptor.Nil();
			root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(TABLE, "TABLE"), root_2);
			adaptor.AddChild(root_2, root_1);
			adaptor.AddChild(retval.Tree, root_2);
		}
	}

insert_columns
	:	(LPAREN column_name_list? RPAREN)?
	;

insert_values
	:	(VALUE|VALUES) LPAREN val+=insert_default_or_expression (COMMA val+=insert_default_or_expression)* RPAREN
			-> ^(INSERT_VALUES VALUES[] $val+)
	;

insert_default_or_expression
	:	DEFAULT
	|	expr
	;
	
set_columns
	:	SET column_assignment (COMMA column_assignment)*	-> ^(SET column_assignment+)
	;

on_dup_key
	:	ON DUPLICATE KEY UPDATE
		column_assignment (COMMA column_assignment)*	-> ^(DUPLICATE column_assignment+)
	;

column_assignment
	:	field_name EQUALS 
		(	DEFAULT			-> ^(EQUALS field_name DEFAULT)
		|	expr			-> ^(EQUALS field_name expr)
		)
	;
	
column_name_list
	:	field_name (COMMA field_name)*	-> ^(COLUMNS field_name+)
	;
// $> Insert

// $< Update

update
	:	UPDATE LOW_PRIORITY? IGNORE?
		table=table_references			// this must be table_references because the mysql parser allows an alias here, even for single table updates (unlike DELETE)
		set=set_columns
		(WHERE where_condition)?
		/* these options are only valid if we update one table */
		({$table.table_count==1}?=> 
			order_by?
			(LIMIT INT_NUMBER)?	
		)?
		-> ^(UPDATE LOW_PRIORITY? IGNORE? $table $set ^(WHERE where_condition)? order_by? ^(LIMIT INT_NUMBER)?)
	;


// $> Update

// $< Delete

/* both multi table delete trees are basically identical. The FROM and USING nodes are just in there to differentiate between the syntax used, in order to format it correctly
   the AST drops potential .* suffixes for the table names, as they are simply syntactic sugar.
*/
delete
@init {
bool multiTableDelete = false;
}
	:	DELETE
		(options{k=1;}: opts+=LOW_PRIORITY | opts+=QUICK | opts+=IGNORE)*		// the yacc parser accepts any combination and any number of these modifiers, so we do, too.
		(	FROM 
			t+=simple_table_ref_no_alias_existing (DOT MULT {multiTableDelete = true;} )? (COMMA t+=simple_table_ref_no_alias_existing (DOT MULT)? {multiTableDelete = true;} )*
			(USING tr=table_references {multiTableDelete = true;})?
			(WHERE where_condition)?
			({multiTableDelete == false}?=>
				order_by?
				(LIMIT INT_NUMBER)?
			)?
								-> {multiTableDelete}? ^(DELETE ^(OPTIONS $opts+)? ^(TABLE $t)+ ^(USING $tr) ^(WHERE where_condition)?)
								 				 	-> ^(DELETE ^(OPTIONS $opts+)? ^(TABLE $t) ^(WHERE where_condition)? order_by? ^(LIMIT INT_NUMBER)?)
								 
		|	t+=simple_table_ref_no_alias_existing (DOT MULT)? (COMMA t+=simple_table_ref_no_alias_existing (DOT MULT)?)*
			FROM tr=table_references
			(WHERE where_condition)?			-> ^(DELETE ^(OPTIONS $opts+)? ^(TABLE $t)+ ^(FROM $tr) ^(WHERE where_condition)?)
		)
	;

// $> Delete

// $< Lock tables

lockTables
	:	LOCK TABLES tables+=lock_table_ref (COMMA tables+=lock_table_ref)*	-> ^(LOCK $tables)
	|	UNLOCK TABLES														-> ^(UNLOCK TABLES)
	;

lock_table_ref
	:	simple_table_ref_alias
		(	READ  (LOCAL )?					-> ^(READ simple_table_ref_alias LOCAL?)
		|	(LOW_PRIORITY )? WRITE 			-> ^(WRITE simple_table_ref_alias LOW_PRIORITY?)
		)
	;

// $> Lock tables

// $> DML

// $< DDL

// $< Create Table

create_table
	:	CREATE (TEMPORARY )? TABLE
		(IF NOT EXISTS )?
		tableName=simple_table_ref_no_alias
		LPAREN create+=create_definition (COMMA create+=create_definition)* RPAREN
		create_table_options? ( ( IGNORE | REPLACE )? AS? select )?
		-> ^(CREATE_TABLE
				TEMPORARY?
				EXISTS?
				simple_table_ref_no_alias
				^(DEFINITIONS $create+)
			)
	;

create_table_options
	:	create_table_option ( COMMA? create_table_option )*
	;

create_table_option
	:	(( ENGINE | TYPE ) EQUALS? engine_name )
	|	( AUTO_INCREMENT EQUALS? INT_NUMBER )
	|	( AVG_ROW_LENGTH EQUALS? INT_NUMBER )
	|	( DEFAULT? CHARACTER SET EQUALS? ( ID | STRING ) )
	|	( CHECKSUM EQUALS? ( { input.LT( 1 ).Text == "1" || input.LT( 1 ).Text == "0" }? => INT_NUMBER) )
	|	( DEFAULT? COLLATE EQUALS? ( ID | STRING ) )
	|	( COMMENT EQUALS? STRING )
	|	( CONNECTION EQUALS? STRING )
	|	( DATA DIRECTORY EQUALS? STRING )
	|	( DELAY_KEY_WRITE EQUALS? ( { input.LT( 1 ).Text == "1" || input.LT( 1 ).Text == "0" }? INT_NUMBER ) )
	|	( INDEX DIRECTORY EQUALS? STRING )
	|	( INSERT_METHOD	EQUALS? ( NO | FIRST | LAST ) )
	|	( MAX_ROWS EQUALS? INT_NUMBER )
	|	( MIN_ROWS EQUALS? INT_NUMBER )
	|	( PACK_KEYS EQUALS? ( ( { input.LT( 1 ).Text == "1" || input.LT( 1 ).Text == "0" }? INT_NUMBER ) | DEFAULT ) )
	|	( PASSWORD EQUALS? STRING )
	|	( ROW_FORMAT EQUALS? ( DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT ) )
	|	( UNION EQUALS? LPAREN simple_table_ref_no_alias ( COMMA simple_table_ref_no_alias )* RPAREN )
	/*|	()*/
	;

engine_name
	:	( MYISAM | INNODB | MERGE | MEMORY | HEAP | BDB | BERKELEYDB | EXAMPLE | FEDERATED | ARCHIVE | CSV | BLACKHOLE ) 
	;

create_definition
	: { input.LA( 1 ) == CONSTRAINT }? ((CONSTRAINT ident? ) 
			(( PRIMARY KEY index_type? LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_type? )
			|	( FOREIGN KEY ( index_name=ident? ) LPAREN index_col_name 
				( COMMA index_col_name )* RPAREN reference_definition )
			|	( UNIQUE ( INDEX | KEY ) index_name=ident? index_type? 
			  	  LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_type? )))
	| { input.LA( 1 ) == PRIMARY }? ( PRIMARY KEY index_type? LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_type? )
	|	( FOREIGN KEY ( index_name=ident? ) LPAREN index_col_name 
				( COMMA index_col_name )* RPAREN reference_definition )
	|	( UNIQUE ( INDEX | KEY ) index_name=ident? index_type? 
			  	  LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_type? )
	|	( ( INDEX | KEY ) ident? index_type? LPAREN index_col_name ( COMMA index_col_name )* RPAREN index_type?	)
	|	( ( FULLTEXT | SPATIAL ) ( INDEX | KEY ) index_name=ident? LPAREN index_col_name ( COMMA index_col_name )* RPAREN
		index_type?	)
	|	( CHECK LPAREN expr RPAREN )?
	|	colName=ident column_definition	-> ^(DEFINITION $colName column_definition)
	;
	
// $> Create Table

column_definition

	:	(data_type
		(notSym=NOT NULL | nullSym=NULL)?
		(DEFAULT literal)?		// TODO check whether literal covers all the legal values
		autoInc=AUTO_INCREMENT?
		(UNIQUE uniqueKey=KEY? | PRIMARY? generalKey=KEY)?
		(COMMENT STRING)? ) 
			-> ^(TYPE data_type
					$notSym?
					($nullSym)?
					^(DEFAULT literal)?
					($autoInc)?				
				)
		// TODO the following two are NDB specific, skipping for now.
//		(COLUMN_FORMAT (FIXED|DYNAMIC|DEFAULT))?
//		(STORAGE (DISK|MEMORY))?
		
	;

data_type
	:	BIT 
		( LPAREN INT_NUMBER  RPAREN )?
	|	(	TINYINT		
		|	SMALLINT	
		|	MEDIUMINT	
		|	INT			
		|	INTEGER		
		|	BIGINT		
		)
		(LPAREN INT_NUMBER  RPAREN)?
		(SIGNED | UNSIGNED )?
		(ZEROFILL )?
	|	(	REAL 		
		|	DOUBLE		
		|	FLOAT		
		|	DECIMAL		
		|	NUMERIC		
		)
		(LPAREN num1=INT_NUMBER COMMA num2=INT_NUMBER RPAREN )?
		(SIGNED | UNSIGNED )?
		(ZEROFILL )?
	|	DATE		
	|	TIME		
	|	TIMESTAMP	
	|	DATETIME	
	|	YEAR		
	|	TINYBLOB	
	|	BLOB		
	|	MEDIUMBLOB	
	|	LONGBLOB	
	|	(	CHAR	
		|	VARCHAR	
		)
		LPAREN INT_NUMBER RPAREN
		(charset )?
		(collate )?
	|	(	BINARY		
		|	VARBINARY	
		)
		LPAREN INT_NUMBER RPAREN
	|	(	TINYTEXT	
		|	TEXT		
		|	MEDIUMTEXT	
		|	LONGTEXT	
		)
		(BINARY )?
		(charset )?
		(collate )?
	|	(	ENUM	
		|	SET		
		)
		LPAREN values+=STRING (COMMA values+=STRING)* RPAREN 
		(charset )?
		(collate )?
	;

charset
	:	CHARACTER SET
		(	ID 
		|	STRING 
		)
	;

collate
	:	COLLATE 
		(	ID 
		|	STRING 
		)
	;
	
reference_definition
	:	REFERENCES simple_table_ref_no_alias LPAREN index_col_name ( COMMA index_col_name )* RPAREN
		( MATCH FULL | MATCH PARTIAL | MATCH SIMPLE )?
		( ON DELETE reference_option )?
		( ON UPDATE reference_option )?
	;

reference_option
	:	RESTRICT
	|	CASCADE
	|	SET NULL
	|	NO ACTION
	;

index_col_name
	:	ident	( LPAREN length=INT_NUMBER RPAREN )? ( ASC | DESC )?
	;

index_type
	:	( USING ( BTREE | HASH ) )
	;
// $> DDL


ifnull_expr
	:	IFNULL LPAREN expr COMMA expr RPAREN
	;

nullif_expr
	:	NULLIF LPAREN expr COMMA expr RPAREN
	;


functionCall
	:	/* builtin functions  */
	  AVG LPAREN expr RPAREN     -> ^(FUNC ^(AVG expr))
	|	BIT_AND LPAREN expr RPAREN		-> ^(FUNC ^(BIT_AND expr))
	|	BIT_OR LPAREN expr RPAREN		-> ^(FUNC ^(BIT_OR expr))
	|	BIT_XOR LPAREN expr RPAREN		-> ^(FUNC ^(BIT_XOR expr))
	|	CAST LPAREN expr AS cast_data_type RPAREN				-> ^(FUNC ^(CAST expr cast_data_type))
	| CONCAT LPAREN exprList RPAREN  -> ^(FUNC ^(CONCAT exprList))
	|	COUNT LPAREN MULT RPAREN		-> ^(FUNC ^(COUNT_STAR[$MULT] ))
	|	COUNT LPAREN expr RPAREN		-> ^(FUNC ^(COUNT expr ))
	|	COUNT LPAREN DISTINCT exprList RPAREN		-> ^(FUNC ^(COUNT exprList DISTINCT))
	|	DATE_ADD LPAREN date=expr COMMA INTERVAL interval=expr timeUnit RPAREN				-> ^(FUNC ^(DATE_ADD $date $interval timeUnit))
	|	DATE_SUB LPAREN date=expr COMMA INTERVAL interval=expr timeUnit RPAREN		-> ^(FUNC ^(DATE_SUB $date $interval timeUnit))
	|	IFNULL LPAREN expr1=expr COMMA expr2=expr RPAREN	-> ^( FUNC ^( IFNULL $expr1 $expr2 ))
	|	GROUP_CONCAT LPAREN 
			DISTINCT? exprList
			order_by?
			(SEPARATOR text_string)?
		RPAREN									-> ^(FUNC ^(GROUP_CONCAT exprList DISTINCT? order_by? text_string?))
	|	MAX LPAREN DISTINCT? expr RPAREN		-> ^(FUNC ^(MAX expr DISTINCT? ))
	// MID is an alias for SUBSTR(str, pos, len)
	|	MID LPAREN expr COMMA expr COMMA expr RPAREN		-> ^(FUNC ^(MID expr+))
	|	MIN LPAREN DISTINCT? expr RPAREN		-> ^(FUNC ^(MIN expr DISTINCT? ))
	|	NULLIF LPAREN expr1=expr COMMA expr2=expr RPAREN	-> ^(FUNC ^(NULLIF $expr1 $expr2 ))
	// SESSION_USER is an alias for USER
	|	SESSION_USER LPAREN RPAREN		-> ^(FUNC ^(SESSION_USER LPAREN))
	|	STD LPAREN expr RPAREN		-> ^(FUNC ^(STD expr))
	|	STDDEV LPAREN expr RPAREN		-> ^(FUNC ^(STDDEV expr))
	|	STDDEV_POP LPAREN expr RPAREN		-> ^(FUNC ^(STDDEV_POP expr))
	|	STDDEV_SAMP LPAREN expr RPAREN		-> ^(FUNC ^(STDDEV_SAMP expr))
	|	SUM LPAREN DISTINCT? expr RPAREN		-> ^(FUNC ^(SUM expr DISTINCT? ))
	// SYSTEM_USER is an alias for USER
	|	SYSTEM_USER LPAREN RPAREN		-> ^(FUNC ^(SYSTEM_USER LPAREN))
	|	TRIM LPAREN
			(	(pos=BOTH | pos=LEADING | pos=TRAILING)
				remstr=expr? FROM str=expr		-> ^(FUNC ^(TRIM $str $pos? $remstr?))
			|	str1=expr
				(	FROM str2=expr				-> ^(FUNC ^(TRIM $str2 $str1))
				|	/* empty */					-> ^(FUNC ^(TRIM $str1))
				)
			)
			RPAREN
	|	VARIANCE LPAREN expr RPAREN		-> ^(FUNC ^(VARIANCE expr))
	|	VAR_POP LPAREN expr RPAREN		-> ^(FUNC ^(VAR_POP expr))
	|	VAR_SAMP LPAREN expr RPAREN		-> ^(FUNC ^(VAR_SAMP expr))

/* non-keywords */
	|	ADDDATE LPAREN date=expr COMMA 
		(	(INTERVAL)=> INTERVAL interval=expr timeUnit RPAREN		-> ^(FUNC ^(ADDDATE $date $interval timeUnit))
		|	days=expr RPAREN		-> ^(FUNC ^(ADDDATE $date $days))
		)
	|	CURDATE LPAREN RPAREN		-> ^(FUNC ^(CURDATE LPAREN))
	|	CURRENT_DATE (LPAREN RPAREN)? -> ^(FUNC ^(CURRENT_DATE LPAREN?))
	|	CURTIME LPAREN RPAREN			-> ^(FUNC ^(CURTIME LPAREN))
	|	CURRENT_TIME (LPAREN RPAREN)?	-> ^(FUNC ^(CURRENT_TIME LPAREN?))
	|	EXTRACT LPAREN timeUnit FROM expr RPAREN		-> ^(FUNC ^(EXTRACT timeUnit expr))
	|	GET_FORMAT LPAREN 
			(type=DATE | type=TIME | type=DATETIME)
			locale=expr
		RPAREN								-> ^(FUNC ^(GET_FORMAT $type $locale))
	|	NOW LPAREN RPAREN					-> ^(FUNC ^(NOW LPAREN))
	|	CURRENT_TIMESTAMP (LPAREN RPAREN)?	-> ^(FUNC ^(CURRENT_TIMESTAMP LPAREN?))
	|	POSITION LPAREN substr=expr IN str=expr RPAREN		-> ^(FUNC ^(POSITION $substr $str))		// todo: LOCATE as well?
	|	SUBDATE LPAREN date=expr COMMA
			(	days=expr			-> ^(FUNC ^(SUBDATE $date $days))
			|	(INTERVAL)=>INTERVAL interval=expr timeUnit	-> ^(FUNC ^(SUBDATE $date $interval timeUnit))
			)
		RPAREN
	// SUBSTR is an alias for SUBSTRING
	|	(funcName=SUBSTR | funcName=SUBSTRING) LPAREN 
			str=expr 
			(	COMMA position=expr COMMA len=expr? 				-> ^(FUNC ^($funcName $str $position $len?))
			|	FROM position=expr (FOR len=expr)? 		-> ^(FUNC ^($funcName $str $position $len? FROM?))
			)
			RPAREN
	|	SYSDATE LPAREN RPAREN				-> ^(FUNC ^(SYSDATE LPAREN))
	|	TIMESTAMP_ADD LPAREN
			timestampUnit
			interval=expr
			date=expr
			RPAREN								-> ^(FUNC ^(TIMESTAMP_ADD $date $interval timestampUnit))
	|	TIMESTAMP_DIFF LPAREN
			timestampUnit
			date1=expr
			date2=expr
			RPAREN								-> ^(FUNC ^(TIMESTAMP_DIFF $date1 $date2 timestampUnit))
	|	UTC_DATE (LPAREN RPAREN)?				-> ^(FUNC ^(UTC_DATE LPAREN?))
	|	UTC_TIMESTAMP (LPAREN RPAREN)?			-> ^(FUNC ^(UTC_TIMESTAMP LPAREN?))
	|	UTC_TIME (LPAREN RPAREN)?				-> ^(FUNC ^(UTC_TIME LPAREN?))

	|	functionCall_conflicts
	|	functionCall_reserved

	/* generic functions we don't know */
	|	name=ID args=parenOptExprList						-> ^(FUNC ^($name $args))
	;

functionCall_conflicts
	:
	/* conflict with keywords, or geometry functions */
		ASCII LPAREN expr RPAREN		-> ^(FUNC ^(ASCII expr))
	|	CHARSET LPAREN expr RPAREN		-> ^(FUNC ^(CHARSET expr))
	|	COALESCE LPAREN exprList RPAREN		-> ^(FUNC ^(COALESCE exprList))
	|	COLLATION LPAREN expr RPAREN		-> ^(FUNC ^(COLLATION expr))
	|	CONTAINS LPAREN e1=expr COMMA e2=expr RPAREN		-> ^(FUNC ^(CONTAINS $e1 $e2))	// geom
	|	DATABASE LPAREN RPAREN		-> ^(FUNC ^(DATABASE LPAREN))
	|	GEOMETRYCOLLECTION LPAREN exprList RPAREN		-> ^(FUNC ^(GEOMETRYCOLLECTION exprList))	// geom
	|	IF LPAREN e1=expr COMMA e2=expr COMMA e3=expr RPAREN	-> ^(FUNC ^(IF $e1 $e2 $e3))
	|	LINESTRING LPAREN exprList RPAREN		-> ^(FUNC ^(LINESTRING exprList))	// geom
	|	MICROSECOND LPAREN expr RPAREN		-> ^(FUNC ^(MICROSECOND expr))
	|	MOD LPAREN e1=expr COMMA e2=expr RPAREN		-> ^(FUNC ^(MOD $e1 $e2))
	|	MULTILINESTRING LPAREN exprList RPAREN		-> ^(FUNC ^(MULTILINESTRING exprList))	// geom
	|	MULTIPOINT LPAREN exprList RPAREN		-> ^(FUNC ^(MULTIPOINT exprList))	// geom
	|	MULTIPOLYGON LPAREN exprList RPAREN		-> ^(FUNC ^(MULTIPOLYGON exprList))	// geom
	|	OLD_PASSWORD LPAREN expr RPAREN		-> ^(FUNC ^(OLD_PASSWORD expr))
	|	PASSWORD LPAREN expr RPAREN		-> ^(FUNC ^(PASSWORD expr))
	|	POINT LPAREN x=expr COMMA y=expr RPAREN		-> ^(FUNC ^(POINT $x $y))	// geom
	|	POLYGON LPAREN exprList RPAREN		-> ^(FUNC ^(POLYGON exprList))	// geom
	|	QUARTER LPAREN expr RPAREN		-> ^(FUNC ^(QUARTER expr))
	|	REPEAT LPAREN str=expr COMMA count=expr RPAREN		-> ^(FUNC ^(REPEAT $str $count))
	|	REPLACE LPAREN str=expr COMMA from=expr COMMA to=expr RPAREN		-> ^(FUNC ^(REPLACE $str $from $to))
	|	TRUNCATE LPAREN num=expr COMMA decimals=expr RPAREN		-> ^(FUNC ^(TRUNCATE $num $decimals))
	|	WEEK LPAREN date=expr (COMMA mode=expr)? RPAREN		-> ^(FUNC ^(WEEK $date $mode?))
	;

functionCall_reserved
	:	/* keywords that can also be function names */
		CHAR LPAREN exprList (USING (charsetname=ID|charsetname=STRING))? RPAREN		-> ^(FUNC ^(CHAR exprList $charsetname?))	// todo: implement proper charset name handling
	|	CURRENT_USER (LPAREN RPAREN)?							-> ^(FUNC ^(CURRENT_USER LPAREN?))
	|	DATE LPAREN expr RPAREN		-> ^(FUNC ^(DATE expr))
	|	DAY LPAREN expr RPAREN		-> ^(FUNC ^(DAY expr))
	|	HOUR LPAREN expr RPAREN		-> ^(FUNC ^(HOUR expr))
	|	INSERT LPAREN 
			str=expr COMMA pos=expr COMMA len=expr COMMA newstr=expr
		RPAREN						-> ^(FUNC ^(INSERT $str $pos $len $newstr))
	// this is not the time INTERVAL operation!
	|	INTERVAL LPAREN exprList RPAREN		-> ^(FUNC ^(INTERVAL exprList))
	|	LEFT LPAREN expr RPAREN		-> ^(FUNC ^(LEFT expr))
	|	MINUTE LPAREN expr RPAREN		-> ^(FUNC ^(MINUTE expr))
	|	MONTH LPAREN expr RPAREN		-> ^(FUNC ^(MONTH expr))
	|	RIGHT LPAREN expr RPAREN		-> ^(FUNC ^(RIGHT expr))
	|	SECOND LPAREN expr RPAREN		-> ^(FUNC ^(SECOND expr))
	|	TIME LPAREN expr RPAREN		-> ^(FUNC ^(TIME expr))
	|	TIMESTAMP LPAREN expr RPAREN		-> ^(FUNC ^(TIMESTAMP expr))
	|	USER LPAREN RPAREN		-> ^(FUNC ^(USER LPAREN))
	|	YEAR LPAREN expr RPAREN		-> ^(FUNC ^(YEAR expr))
	;

/* TODO: Add ASTs for all drops */
drop_database
	:	DROP database_or_schema ( IF EXISTS )? ident -> ^( DROP ^( DATABASE ident ))
	;

database_or_schema
	:	DATABASE | SCHEMA
	;

drop_event
	:	DROP EVENT ( IF EXISTS )? ident -> ^( DROP ^( EVENT ident ))
	;

drop_routine
	:	DROP ( functype=PROCEDURE | functype=FUNCTION ) ( IF EXISTS )? simple_table_ref_no_alias
		-> ^( DROP $functype simple_table_ref_no_alias )
	;

drop_index
	:	DROP ( ONLINE | OFFLINE )? INDEX ident ON simple_table_ref_no_alias
		-> ^( DROP ^( INDEX ident simple_table_ref_no_alias ))
	;

drop_logfile
	:	DROP LOGILE GROUP ident ENGINE ( EQUALS )? ( NDB | NDBCLUSTER )
		->	^( DROP ^( LOGFILE ident ))
	; 

drop_server
	:	DROP SERVER ( IF EXISTS )? ident
		->	^( DROP ^( SERVER ident ) )
	;

drop_table
	:	DROP ( TEMPORARY )? ( TABLE | TABLES ) ( IF EXISTS )? 
		simple_obj_ref_no_alias_existing_list ( cascade_or_restrict )?
		-> ^( DROP { new CommonTree( new CommonToken( TABLE, "TABLE" ) ) } 
			simple_obj_ref_no_alias_existing_list? )
	;

drop_user
	:	DROP user user_specification_list
		-> ^( DROP ^( user user_specification_list ))
	;

drop_trigger
	:	DROP TRIGGER ( IF EXISTS )? simple_obj_ref_no_alias
		-> ^( DROP ^( TRIGGER simple_obj_ref_no_alias ))
	;

drop_view
	:	DROP VIEW ( IF EXISTS )? simple_obj_ref_no_alias_list ( cascade_or_restrict )?
		-> ^( DROP ^( VIEW simple_obj_ref_no_alias_list? ))
	;

simple_obj_ref_no_alias_existing_list
	:	simple_table_ref_no_alias_existing ( COMMA simple_table_ref_no_alias_existing )* 
		-> ^( simple_table_ref_no_alias_existing )+
	;

simple_obj_ref_no_alias_list
	:	obj_ref+=simple_table_ref_no_alias ( COMMA obj_ref+=simple_table_ref_no_alias )* 
		-> ^( $obj_ref )+
	;

cascade_or_restrict
	: type=RESTRICT | type=CASCADE	-> ^( $type )
	;

rename_database
	:	RENAME ( type=DATABASE | type=SCHEMA ) old_dbname=ident TO new_dbname=ident
		-> ^( RENAME ^( $type $old_dbname $new_dbname ))
	;

rename_table
	:	RENAME TABLE table_src_to_dst_list
		-> ^( RENAME ^( TABLE table_src_to_dst_list ))
	;

rename_user
	:	RENAME user newUsers+=user_specification TO oldUsers+=user_specification 
		( COMMA newUsers+=user_specification TO oldUsers+=user_specification )*
		-> ^( RENAME user $newUsers $oldUsers )
	;

table_src_to_dst_list
	:	old_tblname+=simple_table_ref_no_alias_existing TO new_tblname+=simple_table_ref_no_alias 
		( COMMA old_tblname+=simple_table_ref_no_alias_existing TO new_tblname+=simple_table_ref_no_alias )*
		-> ^( $old_tblname $new_tblname )*
	;

truncate_table
	:	TRUNCATE ( t=TABLE )? simple_table_ref_no_alias_existing
		/* This rewrite rule forces a creation of the "optional" TABLE token in the AST. */
		-> ^( TRUNCATE ^( { new CommonTree( new CommonToken( TABLE, "TABLE" ) ) } 
			simple_table_ref_no_alias_existing ))
	;

set_password
	:	SET PASSWORD ( FOR user_specification )? EQUALS 
	(
		PASSWORD LPAREN STRING RPAREN
	|	OLD_PASSWORD LPAREN STRING RPAREN 
	|	STRING
	)	-> ^( SET_PASSWORD user_specification? PASSWORD? OLD_PASSWORD? STRING )
	;

grant
	:	GRANT priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? 
			( COMMA priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? )*
			ON ( object_type )? privilege_level
			TO user_specification_list
			( REQUIRE ( NONE | ( sslopt+=ssl_option ( AND sslopt+=ssl_option )* )) )?
			( WITH withopt+=with_option ( withopt+=with_option )* )?
		->	^( GRANT $priv $collist? ^( ON object_type? privilege_level )
				^( TO user_specification_list ) ^( REQUIRE NONE? $sslopt? )? ^( WITH $withopt? )? )
	;

ssl_option
	:	
	(
		sslopt=SSL
	|	sslopt=X509
	|	sslopt=CIPHER STRING
	|	sslopt=ISSUER STRING
	|	sslopt=SUBJECT STRING
	)	-> ^( SSL_OPTION $sslopt STRING? )
	;

with_option
	:	
	(
		withopt=GRANT OPTION
	|	withopt=MAX_QUERIES_PER_HOUR INT_NUMBER
	|	withopt=MAX_UPDATES_PER_HOUR INT_NUMBER
	|	withopt=MAX_CONNECTIONS_PER_HOUR INT_NUMBER
	|	withopt=MAX_USER_CONNETIONS INT_NUMBER
	)	->	^( WITH_OPTION $withopt INT_NUMBER? )
	;

revoke_user
	:	REVOKE 		
		(
		( ALL ) =>
		(
			 ALL PRIVILEGES COMMA GRANT OPTION FROM user_specification_list
		)	->	^( REVOKE ALL user_specification_list )
		|
		(
			priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? 
			( COMMA priv+=privilege_type ( LPAREN collist+=column_name_list RPAREN )? )*
			ON ( object_type )? privilege_level
			FROM user_specification_list
		)	->	^( REVOKE $priv $collist? ^( ON object_type? privilege_level ) ^( FROM user_specification_list ))
		)
	;

object_type
	:	
	( typeobj=TABLE
	| typeobj=FUNCTION
	| typeobj=PROCEDURE
	)	-> ^( OBJECT_TYPE $typeobj )
	;

privilege_level
	:	
	(
		first=MULT
	  | first=MULT DOT second=MULT
	  | first=ID DOT second=MULT
	  | first=ID DOT second=ID
	  | first=ID
	)	-> ^( PRIVILEGE_LEVEL $first $second? )
	;

privilege_type
	:	
		ALL^ ( PRIVILEGES )?
	|	ALTER^
	|	ALTER^ ROUTINE
	|	CREATE^
	|	CREATE^ ROUTINE
	|	CREATE^ TEMPORARY TABLES
	|	CREATE^ user
	|	CREATE^ VIEW
	|	DELETE^
	|	DROP^
	|	EVENT^
	|	EXECUTE^
	|	FILE^
	|	GRANT^ OPTION
	|	INDEX^
	|	INSERT^
	|	LOCK^ TABLES
	|	PROCESS^
	|	REFERENCES^
	|	RELOAD^
	|	REPLICATION^ CLIENT
	|	REPLICATION^ SLAVE
	|	SELECT^
	|	SHOW^ DATABASES
	|	SHOW^ VIEW
	|	SHUTDOWN^
	|	SUPER^
	|	TRIGGER^
	|	UPDATE^
	|	USAGE^
	/*|	CREATE TABLESPACE*/
	;

/* Special treatment for user keyword due to conflict with checkFunctionAsID function */
user
	:	{ input.LT( 1 ).Text.ToUpper() == "USER" }? => ID	-> ID
	;

create_user
	:	CREATE user user_specification_list
		-> ^( CREATE ^( user user_specification_list ))
	;

user_specification_list
	:	user_specification ( COMMA user_specification )*
		-> ^( user_specification )*
	;

user_specification
	:	user_host_or_id_or_string ( IDENTIFIED BY ( PASSWORD )? STRING )?
		-> ^( user_host_or_id_or_string ( PASSWORD? STRING )? )
	;

user_host
	: AT1 (ID | STRING)	-> ^( USER_HOST ID? STRING? )
	;

user_host_or_id_or_string
	:	ID ( user_host )?		-> ^( USER_HOST_OR_ID_OR_STRING ID user_host? )
		| STRING ( user_host )?	-> ^( USER_HOST_OR_ID_OR_STRING STRING user_host? )
	;

sp_call
	:	CALL ident	-> ^( CALL ident )
	|	CALL ident LPAREN RPAREN	-> ^( CALL ident )
	|	CALL ident LPAREN exprList RPAREN	-> ^( CALL ident ^( exprList ))
	;